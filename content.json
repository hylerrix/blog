{"pages":[],"posts":[{"title":"凝果开源 | 一副程序员扑克牌的故事","text":"2019 年 4 月 25 日，Github Star 第一的开源项目 freeCodeCamp 创始人 Qunicy 发表了一篇文章，《Introducing Programmer Playing Cards》，介绍了一副可以边玩边了解程序员历史的扑克牌。几个月后，因着自己对 FCC China 的持续投入，收到了其中的两份卡牌，也塑造了这篇文章、以及这个开源项目的灵感起源。 整副卡牌共 54 张扑克，包含大小王和四种花色的各 13 张牌。卡牌全部由 100% PVC 材质打造，适度弯曲、浸水以及打火机烘烤都不会影响卡片的耐久度；卡牌包含 54 位程序员先锋的故事，每一张卡片内含一个程序员的生活照片、主要成就清单，以及摘自 TA 的名言——正是这些先锋们开创了现代程序员所依赖的技术。 游历其中，能感受到短短的年代中计算机技术飞跃发展的历史，以及欣赏到每个人对自己所热爱的这份事业所作出的答卷。同时也能看出由于 54 张卡片数量的局限性，无法对更多辛勤贡献的程序员们提供展示的舞台。因此，为了让这份有关“程序员扑克牌”的喜悦能够通过互联网传播、通过开源项目传播，并逐步收录更多的故事，塑造更多的可能性——那就从为其写一份 UI 开始吧！ 值 2020.01.01 新的十年伊始之际，以全新品牌“凝果屋(@ningowood)”为出发点，以全新开源项目“程序员扑克牌(poker-coder)”为着手点，用更多实打实的开源项目驱动学习，开启新十年的开源征程！ 开源项目仓库地址：https://github.com/ningowood/poker-coder开源项目部署地址：https://ningowood.github.io/poker-coder/ 一、54 张扑克牌，54 个技术故事收录的 54 个程序员里，包含有业界耳熟能详的 Ruby on Rails 之父 David、比特币之父中本聪、Linux 之父 Linus、以及有“第一位程序员”以及“第一位女性程序员”之称的 Ada Lovelace……下面我们先大致介绍一下收录中的这 54 位程序员吧。 目录结构分为“大小王 Jokers”、“黑桃 Spades”、“红桃 Hearts”、“梅花 Clubs”、“方块 Diamonds”以及“亚裔程序员”和“女性程序员”板块。其中“亚裔程序员”和“女性程序员”摘自前面花色中，且有重复性，但不妨我们从另一个角度看待全球计算机发展史上亚洲程序员以及最重要却最容易被忽视的——女性程序员的贡献。 大小王 Jokers 借助基于密码证明的电子货币，无需信任第三方中间商，资金就可以安全，交易也不费吹灰之力。——Satoshi Nakamoto(中本聪) 花色 程序员 成就概要 大王 David Heinemeier Hansson 创造了 Ruby on Rails 小王 Satoshi Nakamoto 发明了区块链；设计了比特币 黑桃 Spades 你可以说我在计算上很懒惰，但因此我创造了计算机。——Konrad Zuse 花色 程序员 成就概要 ♠ A Ada Lovelace 发明了计算机算法；编写了第一个计算机程序 ♠ 2 Linus Torvalds 创造了 Linux 操作系统；创造了 Git 版本控制系统 ♠ 3 Bjarne Stroustrup 创造了 C++ 语言 ♠ 4 Patricia Sellinger 帮助创造 System R 项目(SQL 的第一次实现) ♠ 5 Tim Berners-Lee 创造了万维网 ♠ 6 Richard Stallman 发明了 GNU 操作系统；建立了自由软件基金会；创造了 GNU Emacs 编辑器 ♠ 7 Raymond Kurzweil 发明了 OCR(光学字符识别)；开发了首款商用文本语音合成器 ♠ 8 Ken Thompson 发明了 B 语言；合作发明了 Unix 操作系统；合作发明了 Go 语言 ♠ 9 Ray Tomlinson 发明了 Email ♠ 10 Mary Allen Wilkes 为 LINC 设计了交互式操作系统 LAP6；第一个在家中建造和使用个人计算机 ♠ J Edsger Dijkstra 发明了 Dijkstra 最短路径算法；提出了哲学家就餐问题 ♠ Q Douglas Engelbart 发明了鼠标；帮助发明了图形用户界面 ♠ K Konrad Zuse 建造了第一个二进制电脑；建造了第一个可编程数字计算机；设计了第一个高级程序设计语言 红桃 Hearts Python是程序员需要多少自由度的实验。自由度太大，没有人可以阅读别人的代码；太少了，表现力受到了威胁。——Guido Van Rossum 花色 程序员 成就概要 ♥ A Grace Hopper 首创术语“bug”；发明了编译器；合作开发了 COBOL ♥ 2 Andrew Ng 领导斯坦福人工智能机器人项目；领导斯坦福自治直升机项目；上线线上机器学习课程 ♥ 3 Corrinne Yu 为美国航天飞机计划编写代码；为自己创建了 3D 图形引擎；领导 Halo 游戏系列的开发 ♥ 4 Brian Fox 创造了 GNU 的 Bash Shell；合作开发了 OVC 开源投票系统 ♥ 5 Guido Van Rossum 创造了 Python 语言 ♥ 6 Larry Wall 创建了 Git 的前身 Patch，创建了 Perl 语言 ♥ 7 Bob Frankston &amp; Dan Bricklin 创造了第一个电子表格程序 VisiCalc ♥ 8 Adele Goldberg 提出用于图形用户界面的概念；合作开发了 Smalltalk-80 语言 ♥ 9 Brian Kernighan 合作开发了 Unix 操作系统；编写了第一个 “Hello World” 程序；合作发明了 Awk 语言 ♥ 10 Donald Knuth 出版了《计算机编程艺术》；设计了 TeX 类型设置系统 ♥ J Judea Pearl 创建了人工智能的概率方法；发明了贝叶斯网络 ♥ Q John McCarthy 提出了术语“人工智能”；创建了 Lisp 语言 ♥ K Maurice Wilkes 打造了第一台具有内部存储程序的计算机 EDSAC 梅花 Clubs 知识管理首先是要利用信息来提出正确的问题，这本身就是一个巨大且通常是无法识别的挑战。——Dana Ulery 花色 程序员 成就概要 ♣ A Ida Rhodes 从事于“数学表项目”；和 Betty Holberton 一起为 UNIVAC-I 设计了 C-10 语言 ♣ 2 Bram Cohen 创造了 BitTorrent 对等协议 ♣ 3 Brendan Eich 创造了 JavaScript 语言 ♣ 4 Sophie Wilson 设计了橡子微型计算机；开发了 BBC Basic 语言 ♣ 5 James Gosling 创造了 Java 语言 ♣ 6 Bill Joy 创造了 VI 编辑器；创造了 Unix 下的 C Shell ♣ 7 Steve Wozniak 设计了第一台大众市场的微型计算机 Apple II；发明了通用遥控器 ♣ 8 Ward Christensen 开发了一种简单的文件传输协议 XMODEM；第一个公告板 CBBS 共同创始人 ♣ 9 Dennis Ritchie 合作创建了 Unix 操作系统；设计了 C 语言 ♣ 10 Dana Ulery 早期的科学计算应用先锋；建立了电子数据交换标准 ♣ J Frances Allen 为最早的超级计算机之一 IBM Stretch 设计了编译器 ♣ Q Marvin Minsky 发明了神经网络和第一台自学机器；发明了第一台头戴式图形显示器 ♣ K Alan Turing 发明了图灵机；开发出可以破解纳粹加密的计算机；发明了图灵测试 方块 Diamonds 始终如一地编写安全代码要比指出不安全代码要困难得多。——Parisa Tabriz 花色 程序员 成就概要 ♦ A Dorothy Vaughan 计算出了美国太空计划的飞行轨迹；教员工行 FORTRAN 编程 ♦ 2 Parisa Tabriz 监督 Google Chrome 的安全性；成立了安全倡导者会议 ♦ 3 Yukihiro Matsumoto 设计了 Ruby 语言 ♦ 4 Stephen Wolfram 开发了计算机代数系统 Mathematica；开发了应答引擎 Wolfram Alpha ♦ 5 Alexey Pajitnov 设计并开发了俄罗斯方块 ♦ 6 Phil Zimmermann 创建了公共密钥加密程序 Pretty Good Privacy ♦ 7 Radia Perlman 设计了以太网的生成树协议 ♦ 8 Andrew Yao 用极小定理提出姚的极小极大原理；引入通信复杂性理论；提出了姚的百万富翁问题 ♦ 9 Vint Cerf &amp; Bob Kahn 发明了传输控制协议；发明了互联网协议 ♦ 10 Alan Kay 率先使用了面向对象程序设计 ♦ J Margaret Hamilton 负责阿波罗登月任务的软件开发 ♦ Q Jean E. Sammet 合作开发了 COBOL 语言；开发了 FORMAC 语言 ♦ K Vera Molnar 开始迭代组合图像；开始基于几何形状和主题创建算法绘画 亚裔程序员 今天，我实际上很难考虑一个在未来几年内不会被人工智能改变的行业。——Andrew Ng 花色 程序员 成就概要 小王 Satoshi Nakamoto 发明了区块链；设计了比特币 ♥ 2 Andrew Ng 领导斯坦福人工智能机器人项目；领导斯坦福自治直升机项目；上线线上机器学习课程 ♦ 3 Yukihiro Matsumoto 设计了 Ruby 语言 ♦ 8 Andrew Yao 用极小定理提出姚的极小极大原理；引入通信复杂性理论；提出了姚的百万富翁问题 女性程序员 有时我会拥抱我的代码。我会抓取一些代码打印输出，将自己围在几本书中，握住法律垫子，curl 缩在带毯子的沙发上，然后开始阅读并乱涂乱画。[机翻]——Corrinne Yu 花色 程序员 成就概要 ♠ A Ada Lovelace 发明了计算机算法；编写了第一个计算机程序 ♠ 4 Patricia Sellinger 帮助创造 System R 项目(SQL 的第一次实现) ♠ 10 Mary Allen Wilkes 为 LINC 设计了交互式操作系统 LAP6；第一个在家中建造和使用个人计算机 ♥ A Grace Hopper 首创术语“bug”；发明了编译器；合作开发了 COBOL ♥ 3 Corrinne Yu 为美国航天飞机计划编写代码；为自己创建了 3D 图形引擎；领导 Halo 游戏系列的开发 ♥ 8 Adele Goldberg 提出用于图形用户界面的概念；合作开发了 Smalltalk-80 语言 ♣ A Ida Rhodes 从事于“数学表项目”；和 Betty Holberton 一起为 UNIVAC-I 设计了 C-10 语言 ♣ 4 Sophie Wilson 设计了橡子微型计算机；开发了 BBC Basic 语言 ♣ 10 Dana Ulery 早期的科学计算应用先锋；建立了电子数据交换标准 ♣ J Frances Allen 为最早的超级计算机之一 IBM Stretch 设计了编译器 ♦ A Dorothy Vaughan 计算出了美国太空计划的飞行轨迹；教员工行 FORTRAN 编程 ♦ 2 Parisa Tabriz 监督 Google Chrome 的安全性；成立了安全倡导者会议 ♦ 7 Radia Perlman 设计了以太网的生成树协议 ♦ J Margaret Hamilton 负责阿波罗登月任务的软件开发 ♦ Q Jean E. Sammet 合作开发了 COBOL 语言；开发了 FORMAC 语言 隐藏的第 55+ 张扑克：你整副扑克牌 UI 已经变成 CSS 布局，因此在本地可以自定义自己的卡牌。 二、纯前端开源项目开发历程小记本项目目前专注于纯前端技术的建设，主要的前端技术栈如下： React：前端视图层核心库 TypeScript：提供静态类型检查 Material UI：Material Design 风格的 UI 设计库 … React + Material UI 这里不做过多的技术探讨，NingoWood 的主要前端技术选型也将围绕 React + Material Design 搭建前端风格。未来会在学习过程中逐步分享相关技术知识点。 从零到 Create React App，再到正式开发业务代码的小记(构建项目，安装依赖)如下： 123456789101112$ npx create-react-app poker-coder --typescript$ git remote add origin git@github.ningowood/poker-coder.git$ git flow init$ git flow feature start poker-coder$ mkdir src/views src/store src/routes src/config src/components src/commons$ sudo commitizen init cz-conventional-changelog --yarn --dev --exact --force$ sudo yarn add react-router-dom @types/react-router-dom$ sudo yarn add redux react-redux @types/react-redux$ sudo yarn add redux-devtools-extension redux-logger redux-thunk @types/redux-logger$ sudo yarn add @material-ui/core @material-ui/icons axios moment notistack$ sudo yarn add react-i18next i18next$ sudo yarn add --dev less less-loader node-sass react-hot-loader 布局 + 填充 从看到扑克牌 UI 到落实的过程中，需要进行 CSS 思维的转换。每一张卡片分为左侧和右侧的花色姓名栏以及中间的内容部分；内容部分又包括程序员图片、里程碑事件以及名言引用块。 关键的 CSS 突破点在于栅格系统 + 响应式高度来实现扑克牌的宽高比例恒定问题。其实只要会搜索，就会发现可以用 padding-bottom: 140% 来保证高度是宽度的 1.4 倍，然后宽度随着栅格系统改变即可。 容器的 CSS 代码如下，具体可以参考开源项目根目录下 src/components 下的写法。 12345678910111213root: { height: 0, width: '100%', paddingBottom: '140%', position: 'relative',},cardWrap: { height: '100%', width: '100%', backgroundColor: '#fff', position: 'absolute', textAlign: 'center',}, 开源 + 部署 为了贯穿良好的开发习惯，整个开发过程从 Git Flow 的选用以及 Git Commit Message 等角度都做了较好的规范，并最终通过npm run build和npm run deploy部署到 Github Pages 页面上。 截止 v0.1.0 发布，通过 git log --pretty=format:'%ar,%s' &gt; log.csv 命令生成并通过 Emoji 适度修改的 Commit Log 记录如下，统一记录在了 Release 里。 三、v0.1.0 正式发布，以及未来版本蓝图回顾整个开发过程，通过简单的 CSS 布局 + 卡片内容填充以及 Github Pages 部署上线，v0.1.0 正式发布。在这个过程中初期灵感得到实现，也随之而来了各种各样的新灵感。记录在这里，也逐步开放在 Github 仓库中的 issue 里，欢迎大家的加入。 [1] 不仅仅是程序员扑克牌 从之前介绍的隐藏的第 55+ 张扑克牌可以看出：我们不仅仅可以记录程序员的故事，也能记录各行各业先驱的故事；我们不仅仅可以记录人的故事，也可以记录不同事务的故事——如不同的编程语言甚至不同超级英雄的故事——一切都是开放性的。 [2] 不仅仅只有一个卡组 也因此得出这个待做事项——支持更多的卡组，记录更多的人与事。 [3] 自定义卡片与卡组 目前的重点是纯前端实现“程序员扑克牌”项目，这就可以发展出让用户不用克隆项目至本地修改源码来自定义卡片，直接在线编辑卡片并导出，甚至保存在云端。 [4] i18n: 国际化语言 由于这幅扑克牌的介绍都是纯英文的，也因此从纯英文支持出发。接下来逐步开放多语言支持，并对社区提供翻译入口的开放，对中文更加友好。 以及更多… 尾、寒冬寄语，欢迎加入凝果开源社纵观 2019，寒冬越来越“寒”，同时，中文语境下的“程序员”三个字也逐渐变得和“被动”、“猝死”、“淘汰”、“失业”有关。希望我们能够通过这篇文章对“程序员扑克牌”的介绍，通过这个项目对这些“Programmer”的真实记录，重新找回属于自身职业的荣耀，让自己对事业能多添一份激情所在。 那么，欢迎加入凝果开源社，2020 伊始，对未来开源世界的持续支持与关注，就从订阅我们的微信公众号(@ningowood)开始吧！ 我的 Github 地址：https://github.com/hylerrix凝果屋的 Github 地址：https://github.com/ningowood程序员扑克牌的 Github Pages：https://ningowood.github.io/poker-coder/","link":"/blog/2020/01/01/001-ningo-poker-coder/"},{"title":"作为程序员，你在 2019年都有哪些进步、收获与成长？","text":"本文首次回答自知乎，回答原文“作为程序员，你在 2019年都有哪些进步、收获与成长？” 不请自来，答一波，作为我在 b 乎的第一张通行证。 在 2019 年，我完成了从本科生到程序员职场的身份转换。恰好借用隔壁 @沈世钧 前辈的一句话开头，便是——这一年，表面的我波澜不惊，但内心其实经历了巨大的蜕变。 我的“波澜不惊”，体现在对比 15 年到 18 年年底在“城市型线下开源社区”的深度参与下，19 年的我“突然消失”，在开源社区 0 代码输出 0 博文输出；体现在面对日新月异、增速不减的前端新技术（WebAssembly 正式成为第四种 Web 语言、TypeScript 在业界大规模覆盖、React 16 新特性释出、ES6 标准已经发布四年变成 ES10、GraphQL 使用量进一步增长、Serverless 也逐渐被普及）下，曾经喜欢跟着大佬逐浪前行的我，也逐步产生了一种“不慌不慌，够用就好”的蜜汁安全感。 而我的“内心蜕变”，便与此同时进行——曾经为了完成所有线下技术活动的运营任务从头到尾忙活半天以致有点“迷失职业方向”，曾经为了让举办的技术活动能多一点技术主题而强行当“分享者”、甚至曾经有过把“输出技术博客”作为唯一成长关注点而产生“为了博客而博客”的行为——都注定随着本科生涯的结束而尘封，也通过 2019 年在社区上的主动沉寂给自己这段时间所做的一些事画上了句号。 下面我就针对 2019 年选择几个关键主题，进行一次小小的总结。 1. 开源社区与毕业设计随着 freeCodeCamp 在全球范围内逐步的火热，Github Star 量逐步上涨至第一，每个城市都建立起了线下学习小组；再随着我进入大学生活之处就有着关注技术、用博文总结技术的心态，并苦于找不到更多的社区归属感——大一暑假我便自告奋勇当了西安社区的组织者，并在每位 FCC 爱好者的支持下，通过十余场线下活动、近十篇活动运营文案，围绕微信生态从零建立起了数百人的社群。这一去，便是三年；也随着知乎 Live 正式上线，前端界几个大佬（他们也就在这个问题下回答了自己的 2019）开始开 Live，作为听众的我暗中写了笔记并分享也加了大佬们的微信群而人脉圈更广了点；同时 GitChat 正式上线，自己利用不多的影响力写了两篇博文赚了人生的第一桶金，体验了把“技术网红(无贬义)”的知识付费的感觉。 说了这么多，无非想论述清我和开源社区不可磨灭的缘分和感情。也因此，毕业设计主动申请了一个其实用技术实现起来很普通，但深藏了我对“城市型线下开源社区”的深度参与过程中所做的一些感思的课题——“跨平台开源社区运营管理系统的设计与实现”。 设计这个系统，便想从零出发，解决每个技术爱好者平衡技术学习和运营社区的时间矛盾，并助力每一个技术社区在解放繁琐的运营过程后，能做出更多非凡的事情。软件工程设计水平有限，下面是一个简单的系统结构图。 系统结构图： 前端部分使用 Vue 全家桶并配上 UI 库 Vuetify，后端部分使用 Nest.js 系列，并配上 Electron 进行打包，实现了整个项目。由于暂时并不能正式使用，因此暂时也没有开源的计划，下面是其中的一部分截图，凑合着看看。这也就是我在 2019 年的第一个进步、收获与成长。 角色管理： 给角色分配导航： 社区活动管理： 分享主题管理： 2. 大厂编码与互联网寒冬因为对开源的热爱，我爱上了 Github，收获了数百个 follower。也因这份缘分，在几乎没有走面试流程的情况下，当了一个独角兽公司的前端实习生，也顺利的实现了内部转正（Thx！）。来到公司后，由于前端项目技术框架选型的一定自由度，以及带我的导师 Vue、React 一起撸而且还会尽量把新技术及时搬进公司业务代码的原因，我很快熟悉了 Vue + Vuetify 和 Nest.js(用其实现了毕业设计)，也很快熟悉了 React、React Hooks、Ant Design 并自学了 Material UI 库(用其实现了 2020 年的第一个正式开源项目，见下文)。 同时在 2019 年我由前半年的校招生到后半年的转正试用期以及年底的转正答辩，彻底完成了职业化的入门性成长，并在技术上有了很大的提高，这也是我的进步、收获与成长。 同时遇上了传言之为“前 10 年内最坏的一年，未来 10 年内最好的一年”的 2019 年寒冬。见到了各大含金钥匙出生的互联网大厂的各种裁员手段和新闻，以及国内对干技术干不过 35 岁的各种真实性调侃，着实为刚毕业本来就根基不稳的应届生又添上一块冰，也让自己尽早的知道了要珍惜年轻的宝贵，并提前性的、持续性的关注成长，让未来不再惧怕。 这也就是我在 2019 年第二个进步、收获与成长。 3. 第一本，英语原著小说，英语不再畏惧些许讽刺的是，英语四级考试第一次交白卷考场上画画、第二次考完得知自己以 426 分比四级线高出一分时的我，开心的心情就像六级满分一样。我的潜意识一直在抵抗我所从小接触的英语教育模式，但我又没有环境，也不知道如何改进，就这样一直耗到 2019。 在 2019 年双十一中，我为了抵消在北京工作日长时间通勤路上的无聊，剁手买了新出的 Kindle Oasis 3，一股新奇的想法诞生在脑海之中——读原著小说。也因此更进一步，注册了美服亚马逊账号，整个 Kindle 换成美服环境，解锁出了国服没有的“Goodreads”、“Audible Store”等功能。于是看起了可能和很多人一样的，第一部英文原著小说——《Harry Potter and the Sorcerer’s Stone - J. K. Rowling》。 起初每个不认识的单词读起来很困难，我都立马暂停并用 kindle 划词翻译直接翻译成中文来尝试理解。接着喜欢上了故事，有了加快阅读速度的欲望，却依然停滞于不认识的单词之前，“气急败坏”之下左手 Kindle 右手手机版的必应翻译一个一个翻译，常常遇到一句话就得翻译个七八个单词——到两个月后的现在，大多数语气词、修饰词都有了初步的印象，不认识的单词也不一定非得转义成中文来理解，要么继续划词英对英翻译，要么直接在前后文中猜这个单词的意思然后直接略过。 原著小说的阅读能力，不得不承认，有了曾经 200% 的提升——阅读方法和阅读心态占比最多。同时，也让自己正式主动拥抱英语，也不再畏惧英语。 这也是我在 2019 年第三个进步、收获与成长。 4. 2020 伊始，“凝果开源”，再出发！数个月前我一直在想，我到底要成为怎么样的我？就这样否定曾经在社区的不安定性活跃并不再参与开源项目的建设？也彻底放弃写技术博客来总结分享自己的所学，每天上班完成任务后就开始愉快的玩耍？其实某种角度那样的话真的挺开心，但总觉得并不是更真实的自己。 也因此，因毕业设计而对大学阶段我在城市型线下开源社区的感悟做了最终的答卷，也因这个毕业设计过程中所产生的各种灵感再出发，以全新的品牌“凝果屋(NingoWood)”及其社区“凝果开源社”为基石，开始我的新的 10 年——毕竟不想让 2030 年即将“中年危机”的我有太多的遗憾。 这也就是我 2019 最后一个进步、收获与成长。 ————2020 分割线———— 我设计的第一个开源项目是“程序员扑克牌”，灵感来自于 2019 年 freeCodeCamp 出的一副扑克牌。亲自用 React + TypeScript + Material UI 实现了一个 Demo 版本的 UI，并发布了 v0.1.0 版本。https://ningowood.github.io/poker-coder/ 我也因此正式开始拥抱 Github 的英文社区，从开发到 Git Commit 再到 Release、Issue 和 MileStone，都用英文来记录和编写，希望走出更多的国际化脚步。 这两天刚刚宣传，收获了 12 个 Star 和 1 个 Issue，很开心，期待大家一起来玩！我的公众号是“凝果屋的韩亦乐”，WeChat ID 是 ningowood，就酱紫。","link":"/blog/2020/01/03/002-2019-programmer-summary/"},{"title":"深入浅出 Create React App","text":"本文差点难产而死。因为总结的过程中，多次怀疑本文是对官方文档的直接翻译和简单罗列；同时官方文档很全面，全范围的介绍无疑加深了写作的心智负担。但在最终的梳理中，发现走出了一条与众不同的路，于是坚持分享出来。 希望本文除了能带领我们再次了解 Create React App(后文简称 CRA) 外，还能提供一种不同的知识组织结构和技术视角，加深我们对整个 React 技术生态的理解。 本文可能是多篇博客的综合体，整理和写作时间 15h+，仔细阅读时间 30min+，请慢用。 本文面向的读者是： 前端开发初学者或 React 初学者； 使用过 CRA 搭建 React 项目但想拓展相关知识面的人； 希望通过一篇文章快速复习 CRA 的人； 英文初学者，想要通过一篇中文技术文章来让自己接下来读英文文档不再困难的人； 以及就想点进来支持一下的人。 其次，本文在对官方文档进行一定的重新编排下，加上了如下创新点以完善整体的阅读学习体验： 添加了实战 1：使用单个 HTML 文件构建 React App； 添加了实战 2：使用 Webpack 手动构建 React App； 添加了实战 3：使用 CRA 一站式构建 React App； 添加了实战 4：使用 Source Map Explorer 分析打包文件； 添加了实战 5：在已有的 React 项目中引入/升级 CRA； 添加了实战 6：使用 React App Rewired 注入新配置； 添加了：对 CRA 未来版本的简单展望； 添加了：一个 Dan 十年回顾文章的导读。 最终，本文不涉及源码的解读，想要阅读源码的同学可以移步官方源码仓库，整体设计思路并不是很难，具体实现原理可以细细品嚼；且本文对与 CRA 不直接相关的技术点会略略而过，欢迎从点到面主动学习更多。以下是官方源码仓库以及官方文档地址： Github 地址：https://github.com/facebook/create-react-app 官方文档地址：https://create-react-app.dev 初始化 React App 的多种方式常见的初始化 React App 的方式有： 不使用构建工具构建 React App； 使用 Webpack 手动构建 React App； 使用 Create React App 一站式构建 React App； 在在线沙箱平台直接构建 React App（一般用于 Demo 预演，本文不涉及）。 下面我们分别进行介绍与实战练习。 实战 1：使用单个 HTML 文件构建 React AppReact 本身专注于构建用户界面，并不依赖于某个构建工具，因此我们可以用传统的方式引入 React 并书写第一个“Hello World!” App。这种方式是快速尝试 React 的好方法，但并不适用于正式开发。 以下 HTML 代码段是一种实现方式，使用了可选的 Babel 编译和 JSX 语法，基于非构建工具的更多初始化页面的方法（如不使用 JSX 等）可以自行探索。 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt; &lt;!-- 不需要用于生产环境 --&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root') ) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实战 2：使用 Webpack 手动构建 React App构建工具有很多种，目前最为主流的构建工具当属 Webpack。如何使用 Webpack 逐步构建 React App？ 果不其然，为了证明 CRA 的便捷性而引出的本节 Webpack 实战，耗费了一小时多的时间进行了亲自踩坑，搜索了较多的博文都由于发布时间性而不能和最新的版本进行融合，最终根据 Github 中 react-webpack-babel 库的 package.json 文件里的相关信息才得到实现。 123456789101112131415161718# 创建一个项目并进入该项目$ mkdir react-webpack-steper &amp; cd react-webpack-steper# 使用默认选项直接生成一个初始化的 package.json$ npm init -y# 安装 React 基础包$ sudo npm install --save react react-dom# 安装 Webpack 相关工具 - 打包、本地启动支持、本地异步请求模拟以及热更新等$ sudo npm install --save webpack webpack-cli webpack-dev-server# 安装 Babel 相关工具 - 提供 ES6+ 新功能支持$ sudo npm install --save-dev @babel/cli @babel-core @babel/preset-env @babel/preset-react$ sudo npm install --save-dev babel-loader babel-plugin-module-resolver html-webpack-plugin# 新建打包、编译配置文件并准备编写$ touch webpack.config.js$ touch .babelrc# 新建 React 文件$ mkdir src$ touch src/index.js$ touch src/index.html 其中，webpack.config.js 源码如下： 12345678910111213141516171819202122232425262728const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = { entry: path.resolve(__dirname, './src/index.js'), module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' }, ] }, resolve: { extensions: ['*', '.js', '.jsx'] }, output: { path: path.resolve(__dirname, './build'), filename: 'bundle.js', publicPath: '/' }, plugins: [ new HtmlWebpackPlugin({ template: path.resolve(__dirname, './src/index.html') }) ]} .babelrc 源码如下： 12345678{ \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"], \"plugins\": [ [\"module-resolver\", { \"root\": [\"./src\"] }] ]} src/index.html 源码如下： 12345678910&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Hello World!&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;Loading...&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; src/index.js 源码如下： 1234567import React from 'react'import ReactDOM from 'react-dom'ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')) 此时，一个基于 Webpack 手动搭建的简易型“Hello World”App 开发完成，可以通过如下命令本地运行。 1$ webpack-dev-server --mode development --open --hot 更多自定义内容如添加 devServer 支持、添加多页应用支持…等各种各样新技术栈的支持，也可以引申实战。 因此，我们需要 CRA可见，不使用构建工具编写不切实际，使用构建工具手动搭建 React App 又很繁琐。因此我们需要一个能初始化一个可直接运行项目的工具，并提供各种简易的插件，Create React App 应运而生。 CRA 适用于中小型 React 项目。 CRA 的设计哲学 一种依赖关系。尽管 CRA 使用了 Webpack，Babel，ESLint 等各种出色的项目，但我们只需要 CRA 一种依赖；从 CRA 生成项目的 package.json 中也可以看到并没有 Webpack、Babel 的痕迹。 无需配置。我们无需进行任何额外配置便可以直接运行代码，专注业务开发；同时 CRA 还提供了开发和生产版本的合理配置。 非锁定配置。只需要运行一个命令， 所有的配置项和构建依赖项都将直接“弹出”到项目中，交由我们来修改。 CRA 包含了什么？CRA 将具有构建现代单页 React 应用所需的一切： React，JSX，ES6，TypeScript 和 Flow 语法支持； ES6+ 标准的支持，例如对象传播运算符； CSS 自动添加前缀的支持，因此我们不需要 -webkit- 或其他前缀； 快速的交互式单元测试运行程序，内置对覆盖率报告的支持； 实时开发服务器，警告常见错误； 一个构建脚本，用于将 JS，CSS 和图像与哈希和源映射捆绑在一起进行生产； 满足所有渐进式 Web 应用程序标准的 ServiceWorker 和 Web 应用程序清单 支持 （注意：从react-scripts@2.0.0及更高版本开始支持 ServiceWorker）； 单一依赖项即可轻松更新上述工具。 CRA 的使用场景Create React App 非常适合： 在方便且功能丰富的开发环境中学习 React； 快速启动新的单页 React 应用程序； 快速使用 React 为库和组件创建示例。 如果我们想在没有数百个传递构建工具依赖的情况下尝试 React，请考虑使用单个 HTML 文件构建或使用在线沙箱平台构建。 如果需要将 React 代码与服务器端模板框架（如 Rails，Django 或 Symfony）集成，或者如果不构建单页应用，请考虑使用更灵活的 nwb 或 Neutrino。特别是对于 Rails，可以使用 Rails Webpacker。对于 Symfony，请尝试 Symfony’s Webpack Encore； 如果需要发布 React 组件，nwb 以及 Neutrino 的 react-components preset 也可以这样做； 如果要使用 React 和 Node.js 进行服务器渲染，请查看 Next.js 或 Razzle。 Create React App 与后端无关，仅生成静态HTML / JS / CSS包； 如果网站大部分是静态的（例如，投资组合或博客），请考虑改用 Gatsby。与 Create React App 不同，它在构建时会将网站预先渲染为 HTML； 最后，如果需要更多自定义设置，请查看 Neutrino 及其 React preset。 CRA 支持的浏览器一些支持的浏览器规则如下： 默认情况下，生成的项目支持所有现代浏览器。 对 Internet Explorer 9、10 和 11 的支持需要 polyfill。 对于一组支持旧版浏览器的 polyfill，请使用 react-app-polyfill； 默认情况下，生成的项目在 package.json 文件中包含一个 browserslist 配置，以针对基于全球使用情况（&gt; 0.2％）的广泛浏览器（用于生产构建）和用于开发的现代浏览器。 这提供了良好的开发体验，尤其是在使用异步/等待等语言功能时，但仍与生产中的许多浏览器保持高度兼容性； browserslist 配置控制输出的 JavaScript，以使注入的代码与指定的浏览器兼容。 通过运行构建脚本来创建生产构建时，将使用生产列表，而在运行启动脚本时，将使用开发列表。 可以使用 https://browserl.ist 查看配置的浏览器列表支持的浏览器； 请注意，这不会自动包括 polyfills，仍然需要根据所支持的浏览器来添加语言功能（见上文）； 在编辑 browserslist 配置时，我们的更改可能不会立即被获取。 这是由于 babel-loader 中的一个未检测到 package.json 中更改的问题。 一种快速的解决方案是删除 node_modules/.cache 文件夹，然后重试。 这里的重点是 BrowsersList，一个“在不同的前端工具之间共用目标浏览器和 node 版本的配置工具”。简而言之，就是 Babel 等转移工具通过我们设置的 BrowsersList 中想要支持的浏览器版本来决定哪些语法需要被编译。 CRA 支持的 ES 标准一些支持的 ES 标准规则如下： 该项目支持最新 JavaScript 标准的超集。 除ES6语法功能外，它还支持： Exponentiation Operator (ES2016)； Async/await (ES2017)； Object Rest/Spread Properties (ES2018)； Dynamic import() (stage 4 proposal)； Class Fields and Static Properties (part of stage 3 proposal)； JSX, Flow and TypeScript； Learn more about different proposal stages。 尽管 Facebook 建议谨慎使用实验性功能，但 Facebook 会在产品代码中大量使用这些功能，因此，如果将来任何这些建议发生更改，Facebook 都打算提供 codemod； 请注意，默认情况下，该项目不包含任何 polyfill； 如果您使用任何其他需要运行时支持的ES6 +功能（例如Array.from（）或Symbol），请确保手动包括适当的polyfill，或者您要定位的浏览器已支持它们。 CRA 的两个核心库Create React App 有两个核心库，如下: create-react-app 是全局命令，用于创建初始化的 React 项目； react-scripts 是所生成的项目中的开发依赖项，包括运行项目、测试项目、打包项目等多种命令。由于 CRA 的一种依赖性原则，react-scripts 便开放了所有内部其它依赖的使用方式。 实战 3：使用 CRA 构建 React App到这里，我们终于需要通过命令行来安装和使用 CRA，来构建我们的第三个“Hello World”App。 全局安装 CRA为保证每一个新项目都能使用到 CRA 最新最全的功能，请确保 CRA 为最新版本。 1234# 在已安装 CRA 的情况下，可以先卸载 CRA$ npm uninstall -g create-react-app# 正式安装 CRA$ npm install -g create-react-app 初始化 CRA 项目根据我们的 npm 版本，选择相应命令来安装最新版的 CRA 并初始化第一个项目。同时检查自己的 node 版本，需要在本地开发计算机上安装 Node 8.16.0 或 Node 10.16.0 或更高版本（但服务器上不需要）。 我们可以使用nvm（macOS / Linux）或 nvm-windows 在不同项目之间切换Node版本。 1234567891011121314# 查看自己的 npm 版本$ npm --version# 第一种新建项目方式——npm 5.2+ 时，以下命令会安装最新版 CRA$ npx create-react-app my-app# 第一种新建项目方式——npm 版本小于等于 5.1 时$ create-react-app my-app# 第二种新建项目方式# npm 6+ 开始支持 npm init &lt;initializer&gt; $ npm init react-app my-app# 第三种新建项目方式$ yarn create react-app my-app 项目的文件结构通过命令行的构建，我们初始化了第一个 CRA 项目，其中帮我们生成的项目目录结构如下（只有 src 下的文件才会被 Webpack 处理，只有 public 下的文件才能被 public/index.html 使用）： 1234567891011121314151617181920my-app├── .git # 隐藏文件夹，会初始化第一个 Commit 记录├── README.md├── node_modules├── package.json # 依赖配置文件├── .gitignore├── [floder_name] # 根目录下可以建立其他文件夹，但不会被用在生产环境中├── public # 只有 public 下的文件才能被 public/index.html 使用│ ├── favicon.ico│ ├── index.html # public/index.html 页面模板│ └── manifest.json└── src # 只有 src 下的文件才会被 Webpack 处理 ├── App.css ├── App.js ├── App.test.js ├── [floder_name] # 可以建立其他文件夹，以被 Webpack 成功导入 ├── index.css ├── index.js # JavaScript 打包入口文件 ├── logo.svg └── serviceWorker.js 关于 package.json、index.js 和 public/index.html 文件夹，我们通过“实战 2”已经有所了解。前者是 JavaScript 打包入口文件，通常链接整个业务代码；后者是页面模板，是打包后整个静态页面的总入口。 这里对以下两个文件的出现进行简要的意义概括。_ src/serviceWorker.js：提供渐进式 Web 应用的核心功能，不论网络状况如何都能立即加载，并且在不需要网络请求（离线时）的情况下也能展示 UI ； public/manifest.json：是渐进式 Web 应用将自身添加至桌面的功能依赖文件，也可以对图标、名称等信息进行配置。 运行 CRA 项目CRA 默认提供了运行、测试、打包、部署以及弹出项目的命令。其中的一些贴士： npm start 内置热更新机制，代码改动时页面自动刷新； npm test 以交互方式运行测试观察程序，默认情况下运行与自上次提交以来更改的文件相关的测试； npm run build 将要生产的应用程序生成到生成文件夹。它在生产模式下正确捆绑了React，并优化了构建以获得最佳性能。生成文件被压缩，并且文件名包含哈希； npm run eject 将内置的各种 Webpack 配置弹出到项目中，让我们可以进行自定义。同时此操作不可逆，意味着我们承担了弹出配置后的风险。通常不推荐弹出，可以通过 React App Rewired 库进行配置注入。 123456789# ---- 运行 ----$ npm start$ open http://localhost:3000# ---- 测试 ----$ npm test# ---- 打包 ----$ npm run builds# ---- 弹出配置 ----$ npm run eject 搭建 CRA 生态根据官方文档的思路，我们还能从更多角度拓展 CRA 的使用边界，下面进行概要介绍。 为开发环境添加额外功能：包括“配置编辑器风格”、“开发隔离组件”、“分析打包文件”和“添加 HTTPS 支持”； 添加样式与静态资源支持：包括“添加样式表文件”、“添加 CSS Modules 支持”、“添加 Sass 支持”、“添加 PostCSS 支持”、“添加图片文字和字体支持”、“添加 GraphQL 支持”、“使用 public 文件夹”、“进行代码拆分”； 添加业务驱动支持：包括安装各种依赖项如“BootStrap”、“Flow”、“TypeScript”、“Delay”、“Router”，以及“导出组件”、“使用全局变量”、“配置环境变量”、“制作渐进式 Web 应用”和“创建生产环境”； 添加测试支持：包括“运行测试”和“调试测试”； 添加后端集成支持：包括“在开发环境中代理 API 请求”、“使用 AJAX 请求获取数据”、“集成后端 API”和“使用 Title &amp; Meta 标签”； 部署进阶：包括“静态服务器”、“Azure”、“Firebase”、“Github Pages”等平台的部署等。 这里无法深入展开，每一个点都可以是一个新的实战，当我们需要某个功能时便可以查阅相关文档来主动探索。其中“分析打包文件”的解读见“实战 4”。 实战 4：使用 Source Map Explorer 分析打包文件12345678# 安装文件分析工具 source-map-explorer$ sudo npm install --save source-map-explorer# 打包项目$ npm run build# 将如下命令放入 package.json 中并生成快捷方式 npm run analyze# $ source-map-explorer 'build/static/js/*.js'# 注意此命令直接在命令行输入会提示找不到相关命令$ npm run analyze 对于一个刚被 CRA 生成的 React App 来说，分析的结果如下，包大小总计 129.38k。 实战 5：在已有的 React 项目中引入/升级 CRA回到刚才“实战 2”建立的 react-webpack-steper 项目中，当我们已经编写了一部分业务时，能否直接在当前项目中无痛引入 CRA？ 解决思路便是：在大多数情况下，更改 package.json 中的 react-scripts 版本并删除不必要依赖配置，接着在此文件夹中运行 npm install 就足够了，但最好参考更改日志以了解潜在的重大更改。CRA 致力于将重大更改保持在最低限度，以便可以轻松升级 React 脚本。 123456789101112131415# 卸载 CRA 本身已经提供的依赖$ sudo npm uninstall --save webpack webpack-cli webpack-dev-server$ sudo npm uninstall --save-dev @babel/cli @babel-core @babel/preset-env @babel/preset-react$ sudo npm uninstall --save-dev babel-loader babel-plugin-module-resolver html-webpack-plugin# 删除 CRA 不需要使用的文件$ rm webpack.config.js .babelrc# 删除 node_modules$ rm -rf node_modules# 手动安装 React Script$ sudo npm install --save react-scripts@latest# 由于 CRA 默认规则，将 src/index.html 移至 public/index.html$ mkdir public$ mv src/index.html public# 在 package.json 中添加 React Script 启动命令$ vim package.json package.json 中添加/覆盖如下指令。 12345\"scripts\": { \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\", 再次执行即可。由于每个人的具体配置不一定一致，可根据自身所遇问题进行搜索。升级原理类似。 12# 当没有 BrowsersList 时，CRA 会进行询问并帮助我们生成$ npm start 实战 6：使用 React App Rewired 注入新配置CRA 官方并不推荐使用 npm run eject 弹出配置，这会增加更多的 Webpack 维护工作。对于实在想改的 Webpack 配置来说，我们可以使用 React App Rewired 库进行配置注入，这里来做个小例子。 此工具可以在不 ‘eject’ 也不创建额外 react-scripts 的情况下修改 create-react-app 内置的 webpack 配置，然后你将拥有 create-react-app 的一切特性，且可以根据你的需要去配置 webpack 的 plugins, loaders 等。 继续使用 react-webpack-steper 项目，我们的简易目标是增加 devServer 本地代理。 第一步：安装依赖并进行基础配置 12345678# 安装依赖$ sudo npm install --save-dev react-app-rewired customize-cra# 根目录建立 config-overrides.js$ touch config-overrides.js# 修改 package.json$ vim package.json# 运行项目$ npm start 其中，config-overrides.js 的初始代码为： 12345/* config-overrides.js */module.exports = function override(config, env) { //do stuff with the webpack config... return config;} package.json 的修改思路为： 12345678910/* package.json */\"scripts\": {- \"start\": \"react-scripts start\",+ \"start\": \"react-app-rewired start\",- \"build\": \"react-scripts build\",+ \"build\": \"react-app-rewired build\",- \"test\": \"react-scripts test --env=jsdom\",+ \"test\": \"react-app-rewired test --env=jsdom\", \"eject\": \"react-scripts eject\"} 第二步：编写配置，进行代理 12345# 新增配置文件$ mkdir config$ touch config/proxy.js# 修改 config-overrides.js$ vim config-overrides.js 其中，config/proxy.js 源码是： 1234567module.exports = { '/api/**': { target: 'http://110.114.120.120:8080', secure: false, changeOrigin: false, },} config-overrides.js 修改为： 123456789const { overrideDevServer } = require('customize-cra')const proxy = require('./config/proxy')module.exports = { devServer: overrideDevServer((config) =&gt; { config.proxy = proxy return config }),} 此时，本地的所有 api 开头的接口请求都会被转发到 http://110.114.120.120:8080 的模拟后端 IP 上。 对 CRA 未来版本的简单展望截止目前(2020-01-10)，CRA 的最新版本是 v3.3.0，我们可以从 Github 的 MileStone 中看到未来可能会改善的功能，其中整理并如下所述。 v3.x：添加多入口文件支持（不只是一个 index.js 入口）；使用 worker-loader 添加对 WebWorker 的支持；更早地检查 Node 的版本；添加对子资源完整性 SRI 支持；生产环境中预加载脚本和链接… v4.0：支持 Webpack 5.0（Webpack 目前最新版 v4.41.5，v5 也推出了一年多内测版）；在 tsconfig.json 和 jsconfig.json 里新增对 baseUrl 和 paths 的支持（方便写 @ 绝对路径等）；支持 Jest 配置中设置browser 为 true（根据环境提供正确的 Node 或 Browser 模块）… v100.0：提供构建过程中的监视模式；适用于 Hooks 的热加载… 让我们一起持续关注。 结语回顾文章，我们从初始化 React App 的多种方式，引出 CRA 的必要性再对其进行较为充分的解释，最后配上 6 个角度来从一些角度对 CRA 的使用方式进行了实战，最后回归到 CRA 的版本展望之中。 感谢你的阅读，如果你有什么更多的疑惑，CRA 的官方文档 + 开源仓库一定会满足你的一切。 最后，一起拜读一下 CRA 和 Redux 作者、React 的核心贡献者 Dan Abramov 发布的这篇“我的十年回顾”文章。 现在我们可以开始正式深入地学习 React 技术栈了。","link":"/blog/2020/01/10/003-create-react-app-intro/"},{"title":"开源爱好者月刊：第 1 期（202001）","text":"序言本刊从自身对开源的爱好出发，计划先以每月一刊的形式更新。同时，本刊站在众多巨人的肩上：便捷访问也精彩万分的各大国际开源媒体；辛勤维护很久的《开源之道》和《科技爱好者周刊》等国内博文期刊；以及从黑客文化诞生以来默默付出的每一位开源爱好者……离开这些或许现在会大不相同。 本杂志开源（GitHub: ningowood/open-source-magazine），欢迎提交 issue，投稿或推荐你的开源内容。 资讯01、展望 2020 开源世界：未来看起来一片光明 发布时间：2019-12-18 作者简介：Jack Wallen 是 TechRepublic 和 Linux.com 的荣誉作家。他是开源的狂热拥护者，也是 Android 专家之一。 Jack Wallen 对即将到来的 2020 年的开源世界（Linux、Docker 引擎、自动化）等方面等进行了如下预测。 Deepin Linux 将改变开源格局。Deepin 15.11 的开发人员计划发布 Deepin Cloud Sync 功能，该功能可能会改变 Linux 发行版的构造板块。此功能会将用户选择的系统设置同步到云。 例如，用户可以安装操作系统的另一个实例，将其连接到 Deepin Cloud Sync 个人帐户，然后让该新的操作系统实例自动同步设置。 想象一下，部署多个桌面实例将节省多少时间。 预装 Linux 的机器将表现得更出色。预计会有更多的厂商加入竞争，到 2020 年即将结束时，如果地球上所有台式机和笔记本电脑制造商都提供某些硬件的Linux版本，请不要感到惊讶。 开源将主导更多的企业。在云，容器，大数据，物联网（IoT）和边缘计算领域，开源无处不在。纵使 Windows 在台式机上还处于强势地位，但其安全性不容忽视，我们也要为到 2020 年底至少在小范围内改变这一现状做好准备。 Docker 引擎将有所反弹。2019 年 Kubernetes 成为了首选的容器协调器，对于 Docker 来说并不是好事。但随着 Kubernetes 变得越来越强大，它也变得越来越复杂；同时对用户友好的 Docker Swarm 工具或新的客户端工具的出现，也大大简化了 Docker 集群的编排。如果 Docker 可以在保持其功能和灵活性的同时恢复简单性，它将重新获得一些的市场份额。 开源自动化将令人“恐惧”。由于推动了更高效率的 CI / CD 管道，我们见证了令人印象深刻的自动化技术的兴起。到 2020 年，开源自动化将接近虚构的领域，其系统会自行“思考”，并且我们将首次体验一种基于经验（来自 AI）和预测进行自我优化的系统。 NVIDIA 将揭晓有关 Linux 的惊喜。NVIDIA 宣布在 2020 年推出 Linux 版时会有一个很大的惊喜。我们相信NVIDIA 计划做两件事之一：为 Nouveau 驱动程序做贡献，或者开源它的官方 NVIDIA 驱动程序。 我们认为 NVIDIA 看到了很多东西，而加入 Linux 是前进的唯一途径。这可能是 Linux 台式机游戏的福音，并且可以推动 Linux 普及率的上升。 02、20 年代的 5 种技术趋势，区块链，云，开源，人工智能，知识图谱 发布时间：2020-01-03（第一部分）2020-01-16（第二部分） 作者介绍：George Anadiotis 为《财富》 500强、初创企业和非政府组织提供顾问，建立和管理各种规模和形状的产品和团队，其研究屡获殊荣。 数据正在改变从业务到社交互动的一切范例；数据正在塑造一种新的文化，带来了一种新的经商方式，一种新的决策方式，新的应用程序和基础架构，并且是向 AI 过渡的推动力。如下列出未来几年将影响数据格局的因素。 区块链。数据的不可篡改性正是推动比特币以及区块链发展的动力，比特币开启了可能性的领域，但也引发了巨大的炒作，无知和欺诈浪潮。今天，区块链似乎已经触底。 Gartner 将区块链置于幻灭槽的底部。Onecoin 和 Bitfinex-Tether 这样的骗局就是区块链已成为狂野西部的例证，而 Facebook 的 Libra 也没有受到广泛关注-这貌似是一件好事。 云。十年前，对于大多数企业而言，云并不是真正的大规模数据和计算选择，Big Data 的解释和现在大不相同。如今，在选择数据管理解决方案时，候选名单几乎总是包含云供应商提供的产品。通过单一控制平面进行云端本地化，管理和计费，以及具有多区域可用性使云供应商的产品更具吸引力。 开源。开源在数据库和其他方面都是赢家，发生这种情况的原因有很多：进入门槛低，社区，创新，互操作性低。到 2022 年，超过 70％ 的新内部应用程序将在开源数据库上开发，并且 50％ 的现有专有关系数据库实例将已转换或处于转换到开源的过程中。 人工智能。2010 年代的后半部分都是关于 AI 的，而 2020 年代也不会有什么不同。我们将看到 AI 扩大其范围，并影响每个可能的领域。但是，已经看到了 AI 炒作的兴起，我们还必须为反弹而做好准备。知道“ AI”的实际含义非常重要。 知识图谱。与 AI 一样，数据爆炸也推动了图形技术的发展。利用数据中的关系是从数据中获取价值的一种突出方式，而图则是利用数据关系的最佳方法。知识图谱是一种技术，它可以使其他技术加速其发展，也可以使人们评估自己的知识。 03、为什么带有 Commons Clause 的开源许可证不会普及 发布时间：2020-01-13（非首次发布） 作者介绍：Stephen E. Kabakoff 和 Nicholas Petrella 专注于计算机和电气技术领域的诉讼、客户咨询和专利起诉工作。在他们与初创公司以及成熟行业中担任软件工程师的合作经验中，为客户提供专利战略和产品组合开发方面的咨询。 “还是那句话，开源赚钱要赚的聪明，而不是被人们以为是打着道德的幌子欺世盗名。Commons Clause 等软件供应商能走多远，还是要经过市场验证的，当然，法律界的声音也很关键。” ——开源之道发起人，X-lab 开放实验室常任秘书长，开源社执委会成员，适兕 04、中科院学者自主创造的编程语言因涉嫌抄袭 Python 被停职 发布时间：2020-01-21 作者简介：Yuan Yang 是北京《金融时报》的中国技术记者。她与他人共同创立了 Rethinking Economics，这是一家总部位于英国的慈善机构，致力于在全球大学中开展更加多样化的经济学教育。 中国科学院计算技术研究所（ICT）的研究员刘雷上周宣布，他的研究小组“独立”开发了一种新的编程语言，以传说中的女主人公命名为花木兰，并吹捧为“人工智能和物联网的应用”。刘雷指出，“木兰”编程语言体系具有易学、易教、强兼容、支持人工智能和物联网开发等四个技术创新特点，同时支持跨平台操作，兼容 Android、IOS、Linux、Windows 系统，并支持龙芯、寒武纪等多类型中国国产处理器。“木兰”编程语言体系当前正以人工智能教育行业为切入点，通过教材研发、教学装备、科普公益等进行应用推广，以逐步实现整个产业生态的发展和构建。 几天后，刘先生向国内媒体承认，木兰是基于 Python 的一种编程语言，该语言的组件可通过“开源”许可免费获得，并且其主要目的是为儿童教授程序，而不是为 AI 应用程序。Nian Liu 补充道，“2018 年，中国初创公司 Redcore 公开道歉，承认其声称是“中国第一台自主开发”的网络浏览器主要基于 Google 的开源浏览器项目 Chromium”。 05、开放 Windows 7 源代码 发布时间：2020-01-23 作者简介：Greg Farough 是一名纯素食主义者，曾担任过牧民，劳工组织者和阁楼希腊人的家庭教师。Greg 在 2006 年用 Punkcast 视频播客的方式介绍了自由软件：当他打算观看音乐会的盗版作品时，看到了 RMS 的演讲，从那一刻起，他决定使用完全免费的系统。 1月14日，Windows 7 “寿终正寝”，结束了其更新以及长达十年的“毒化教育”——侵犯隐私权和对用户安全的威胁。 Windows 7 生命周期的结束为 Microsoft 掩盖了过去的错误并失去了对其进行升级的绝佳机会。 FSF（自由软件基金会） 呼吁他们将其作为免费软件发布，并提供给社区进行研究和改进。由于已有一些将 Windows 核心实用程序作为免费软件发布的先例，因此，Microsoft 开源他们自己所说的“已到尽头”的操作系统版本是没有损失的。 致微软高管： 我们要求 Windows 7 作为免费软件发布。它的生命不必结束，请将其提供给社区进行研究，修改和共享。 我们敦促您尊重用户的自由和隐私-不仅仅是将所有用户升级到最新的 Windows 版本中。 我们需要更多的证据来证明您确实尊重用户和用户自由，而不仅仅是在方便时将这些概念用作营销。by Free Software Foundation 06、中国与开源政治策略(英文) 发布时间：2020-01-27 作者简介：Matt Asay 是一位资深的技术专栏作家，曾为 CNET，ReadWrite 和其他技术媒体撰写过文章。 Asay 还在领先的移动和大数据软件公司中担任过各种执行职务。 战略家 Simon Wardley 说，中国在开源领域的长期竞争力日益高涨。Wardley 认为，在中国，人们渴望取胜是一个长期的愿望，而开源在其中扮演着越来越重要的角色；开放式的方法可以用来在特定方向主动改变市场。如果使用得当，这将是一个非常强大的系统。根据 Lisa Caywood 的说法，“从中国的角度来看，这是一个防御，同时也能确保它们可以与世界其他地区的技术基础架构有效地整合。” 聪明的公司（和国家）将越来越多地使用开源来推动长期价值。 07、一句话消息 Uber 开源 Manifold，一个用于调试 AI 模型的可视工具，可显示特征分布的差异（即所观察到的现象的可测量特性）。[2020-01-07] T-Mobile Poland 率先在 ONF（开源网络基金会） 部署开源 EPC（4G 核心网络）。[2020-01-09] 华为开源 openEuler 操作系统，openEuler 是基于 CentOS 的 Linux发行版，源代码发布在中文 Github 替代产品 Gitee 上，同时开放上千个代码仓库。[2020-01-09] 佛蒙特大学（UVM）从 Google 获得 100 万美元用于开源研究。[2020-01-13] Facebook 回顾其 2019 年开源成果，其中发布了 170 个新项目，有 579 个活跃代码仓库，总计 82,000 次 Commit，大约 2,500 名外部贡献者提交了超过 32,000 个 Commit。[2020-01-13] Microsoft 开源了用于检查其应用程序中不受信任的第三方软件组件的安全工具 Application Inspector。[2020-01-17] CentOS 仓库公开决策指南，CentOS 的下游如果不按照 RHEL/Fedora 的文化和规范走，将会“死的很难看”。[2020-01-21] 开源网络安全初创公司 Snyk 在不到五年的时间里市值就超过了10亿美元，CEO 解释了过去四个月收入如何翻了一番。[2020-01-23] 波士顿动力机器狗 Spot 的开源代码免费提供给所有人，该版本将允许开发人员和机器人技术人员“开发自定义应用程序，使 Spot 能够在众多行业中完成有用的任务”。[2020-01-24] The Open Book 是由开发商 Joey Castillo 创建的完美 Kindle 替代品，这是一款进行中的、不受企业限制的开源电子阅读器，具有小型 E Ink 显示屏，开源软件和开放硬件。[2020-01-27] 开源软件 THERMOS 支持低碳区域能源网络规划，提供标准 Web 浏览器访问并直接在线确定城市中最佳热网选项等功能，以充分利用低碳能源和提高空气质量。[2020-01-27] 开源电子邮件客户端 Thunderbird 找到了新的家：在近年来 Mozilla Corporation 决定停止对其进行支持导致的曲折发展后，Mozilla 基金会的新全资子公司 MZLA Technologies Corporation 开始运营，Thunderbird 将继续保持免费和开源。[2020-01-29] 项目01、wuhan2020：开源爱好者携手对抗新冠肺炎 针对 2020 年初在武汉爆发的新型冠状病毒疫情，wuhan2020 项目旨在收集各医院、酒店、工厂、物流、捐赠、捐款、预防、治疗、动态等信息，统一收集，统一发布，以便各方之间进行信息互通，有效调配社会资源。wuhan2020 从发起以来，短短几天，号召了众多开发者与志愿者的参与。 02、VVVVVV：一款 Steam 上好评如潮的游戏 VVVVVV 是一款在 Steam 上好评如潮的游戏，游戏探索的设定非常简单：玩家不能跳跃——不过，玩家只按一个键就能将自身重力反转。值 VVVVVV 发布十年之际，这款游戏近期已经在 Github 上开放源代码。 鉴于游戏中的图标，艺术，图形和音乐仍处于专有许可下，VVVVVV 仓库本身只包括游戏中的所有关卡内容和文本，但对于个人使用的情况下，可以在“制作即玩版”中免费找到这些资产。 03、Reachy：一个富有表现力的开源机器人 2020 年国际消费电子展（CES）上的“揭幕”活动中公布了开源机器人 Reachy 的动态。受到生物学启发，Reachy 的手臂具有 7 度的移动自由度，并且可以配备多种机械手，从抓夹到五指人形机器人。该公司避免使用 Wall-E 式的情感显示器，而是采用专用的颈部接头，该接头可使机器人的头部以令人惊讶的人类方式旋转，摇动和倾斜。 该软件触手可及的硬件和软件都是开放源代码，可以由最终用户自由修改/定制以适应其需求。其中，软件部分建立在 Pypot 库的顶部，并根据 LGPL 许可证分发；硬件部分根据 Creative Commons BY-SA 许可证使用 OnShape 制造。 04、chaos-mesh：一个 Kubernetes 的混沌工程平台 Chaos Mesh 是一个云原生的混合工程平台，可在 Kubernetes 环境中协调混乱。 品牌01、[网站] 开源之道 开源之道以文布道开源，内容覆盖开源文化、方法论、商业、认知、心理、成系统的某 IT 项目等，旨在传播开源理念，让中国本土与世界更同步，以创新的方式应对这个变化的世界。开源之道发起人适兕，也是 X-lab 开放实验室常任秘书长，开源社执委会成员。 02、[基金会] Linux 基金会 Linux 基金会（英语：Linux Foundation，简称 LF），是一家非营利性技术贸易协会，致力于促进，保护和推进Linux 和协同开发，并支持“历史上最大的共享技术资源”。它开始于 2000 年的开源码发展实验室（OSDL），并与自由标准组织（FSG）合并后从而成为现在的组织。Linux 基金会赞助 Linux 创始人 Linus Torvalds 和主管维护者 Greg Kroah-Hartman 的工作 并由领导 Linux 和开源公司的支持，包括思科，富士通，惠普，IBM，英特尔，微软，NEC，甲骨文，高通和三星等知名的科技公司，以及来自全世界的开发商 。近年来，Linux基金会通过活动，培训和认证以及开源项目扩大了服务范围。 03、[网站] opensource.com 2010 年，红帽首席执行官 Jim Whitehurst 在题为“欢迎访问 Opensource.com 上的对话”的帖子中宣布了 Opensource.com 的启动。他解释说：“该站点是 Red Hat 向开源社区回馈某些东西的一种方式。我们的愿望是为对话建立一个联系点，以讨论开源和软件世界。”他写道，并补充道：“欢迎所有想法，欢迎所有参与者。这不是 Red Hat 关于 Red Hat 的网站，而是关于未来的开源网站。” 到 2013 年，Opensource.com 每月平均发布 46 篇文章，而在 2016 年 3 月，Opensource.com 的页面访问量首次超过 100 万。在 2019 年，Opensource.com 平均每月有 150 万以上的页面浏览量和 90 篇文章。由工作人员编辑和社区主持人组成的小型国际团队与来自世界各地的数百名撰稿人紧密合作，策划，完善，发布和推广开源故事。 2015 年以来每年的年度开源报告，以及更多的英文开源资料都可以免费下载。 04、[网站] opensource.org 20 多年来，OSI（Open Source Initiative）一直致力于提高人们对开源软件的认识和采用，并在开源实践社区之间建立桥梁。 作为一个全球性的非营利组织，OSI 通过教育，协作和基础设施，指导开源定义（OSD）并防止滥用开源运动固有的理想和精神来捍卫社会中的软件自由。 开源软件是由许多人制作的，并在符合 OSD 的许可证下分发，该许可证授予所有以修改和未修改形式使用，学习，更改和共享该软件的权利。 软件自由对于实现社区开发开源软件至关重要。 05、[会议] OSCON 和社区领袖峰会 OSCON（The O’Reilly Open Source Convention）是由计算机科学出版行业的 O’Reilly 公司组织的自由和开源软件会议。OSCON 堪称是开源世界历史最悠久的大会，第一次是在 1999 年举办，在全球开源爱好者中声誉颇高。 社区领袖峰会汇集了对发展和强大社区感兴趣的社区领袖，组织者和管理者以及相关的项目和组织。同时，该活动汇集了社区管理和在线协作方面的领先思想，以讨论、辩论、完善和构建更好的社区。活动将主题演讲，非会议会议和小组讨论等混合在一起，以带来由不同受众驱动的丰富内容。 在社区领袖峰会中，可以向来自不同行业的社区领导者学习技术和方法；分享自己的经验，方法和观点，以帮助人们在各种职业中培养社区领导能力；结识来自世界各地的迷人社区领袖，扩大自己的友谊和人脉网络；通过反馈和想法扩大自己的技能和潜力。 荐书《大教堂与集市》 自由不是一个抽象的商业概念。任何行业的成功几乎都直接和这个行业供应商及客户所享有的自由度相关，对比美国电话业在AT&amp;T失去垄断地位前后的创新步伐，就能知道用户享有选择的自由是多么重要。计算机硬件行业和软件行业的对比，是体现自由给行业带来益处的最好示例。在计算机硬件行业，供应商和消费者在全球范围内都享有很高的自由度，所以该行业在产品和客户价值方面的创新速度，是人类前所未见的。而在软件行业，其变化则几乎以十年为单位，办公套件是20世纪80年代的杀手应用，其地位直到90年代才受到浏览器和Web服务器的挑战。&gt; 开源软件给软件行业带来的自由，可能要比硬件行业制造商和客户所能享受的自由更广阔。——《大教堂与集市》序 大教堂与集市是开源运动的独立宣言，它清晰、透彻和准确地描述了开源运动的理论与实际应用，对开源软件运动的成功和 Linux 操作系统的广泛采用起到了至关重要的作用。本书在开源运动中的地位相当于基督教的圣经，用黑客们的话说，这是“黑客藏经阁”的第一收藏。 凝果 2020 年 01 月凝果屋动态汇总： 本月新增博文： 《凝果开源 | 一副程序员扑克牌的故事》 《作为程序员，你在 2019年都有哪些进步、收获与成长？》 《Create React App 钻研之术》 《开源爱好者月刊：第 1 期（202001）》 本月开源动态： 程序员扑克牌 翻译五十四个程序员的简介为中文； 新增国际化语言支持； 初步提供多卡组支持； 添加 Github Logo 外链到源码仓库； 添加顶部公告牌进行简单的公告； 将以上更新内容合并发布为 v0.2 版本； …… 开源爱好者月刊 发布第一期月刊。 次月开源规划 [动态调节]（2020 年 02 月）： 程序员扑克牌 [普通][合作+] 新增卡组：54 个知名编程语言卡组； [普通][合作+] 新增卡组：54 个知名开源项目卡组； [较难] 突破大小王扑克牌限制，支持多种卡组布局； [普通] 优化首屏性能：图片懒加载； [简单] 根据已上多个卡组及其布局优化卡组选择功能； [简单] 新增卡牌背面，每张卡牌提供翻转动画； [简单] 卡牌可单张导出为 PNG 文件； [普通] 修复一些已知问题； …… 内部实验项目(择机正式开源) 本月开源贡献者感谢： @hylerrix @wolfgirlm 本刊每月底择机发布，同步更新在 Github、微信公众号（见下图）和语雀中，任何想法和新内容的推荐欢迎以 Github Issue 的形式进行交流与知识共享。 P.S. 更多及时内容，欢迎关注公众号留言“加群”后，加入微信社群交流。 P.S. 2020 年 02 月会围绕微信群发布问卷，向大家征集“知名的编程语言”和“知名的开源项目”有哪些，并一起定稿卡牌内容，请不要错过！","link":"/blog/2020/01/10/004-osm-001/"},{"title":"开源爱好者月刊：第 2 期（202002）","text":"开源软件占所有软件的 80%-90%；二十年前一线程序员月薪 3000+，一台 32mb 内存电脑 8000+；如何吸引运营人员参与开源社区……开源的世界精彩万分，数不胜数；最后推荐一本书，介绍为什么“科学”曾是一种十分罕见的文化现象，根源于希腊人对于自由人性的追求。 序言本刊从自身对开源的爱好出发，计划先以每月一刊的形式更新。同时，本刊站在众多巨人的肩上，离开这些或许现在会大不相同。 本杂志开源（GitHub: ningowood/open-source-magazine），本月开始提供了各大平台信息源可以进行更多深入的阅读。更多动态，欢迎提交 issue，投稿或推荐你的开源内容。 根据第一期反馈，尝试写一次目录，摘要如下。 2020 年热门编程语言的发展方向 我们分析了GitHub上5.46 亿条日志，发现中国开源虽然贡献大但还有这些不足… 开源的两种局面 Linux 基金会披露最常用的开源组件及其安全问题 企业开源软件正在创新型公司中成长 2019-2020 中国开发者调查报告完整版 推荐项目“Rome”、“Pytorch”和“Scalar” 推荐品牌“O’Reilly”、“InfoQ”和“开源社” 推荐书籍《什么是科学》 资讯01、2020 年热门编程语言的发展方向 发布时间：2020-01-13 作者简介：Zan McQuade 和 Amanda Quinn 均是 O’Reilly 编程语言领域的高级编辑。Zan McQuade 专注 Java/JVM，Go 和 Android 内容，在加入 O’Reilly 之前，她在 Penguin Random House 从事外语教学内容工作了将近二十年；Amanda Quinn 关注 Python/C++ /C# 和 Rust 内容。 2020 开启了新的十年，O’Reilly 的两位编辑向多位编程语言专家征询了他们对当前热门编程语言的看法。 Python。2019 年年底 Python 之父宣布退休，权利转移过程还算顺利，留下了一个健壮的社区。《Python 编程从入门到实践》作者 Matthes 表示，Python 在一个长期以来刻意构建其多样性的社区中，出现了各种有趣而关键的项目。 Java。Java 13 版本已经发布，超过 80% 的开发人员仍然使用 Java 8。尽管开发人员采用新版本的速度很慢，但 Java 每六个月发布一次的节奏一直在不断延续。 Kotlin。谷歌在 2019 年 5 月宣布，Kotlin 现在是 Android 应用程序开发人员的首选语言。不同 Kotlin 平台之间的屏障也正在被打破——“expect”/”actual” 限定符使开发人员可以更轻松地编写跨 Java/Native/JS 环境的兼容代码。现在，序列化支持意味着可以更容易地将 JSON 数据转换为 Kotlin 对象，反之亦然。KotlinConf 会议门票连续三年售罄，尤其表明人们对这门语言的兴趣和接受程度正在增长。 Go。2019 年 6 月，针对 Go 的抱怨之一错误处理过于冗长，Go 的核心开发者提议添加一个新的内置函数 try 并开放讨论，最终在大多数人的意见下否决了本次提案。Go 的社区很友好活跃。同时，2020 年 Go 的契约规范（也就是众所周知的泛型提案）应该会更加清晰。 Rust。《Programming Rust》的合著者 Jim Blandy 指出，Rust 长期以来一直以多样的形式支持异步编程，async/await 语法意的支持依然进行中。Rust 社区对 WebAssembly 很感兴趣。 Swift。2019 年 SwiftUI 和 Swift for TensorFlow 发布。SwiftUI 可用于在所有苹果设备上设计用户界面，凭借其声明式的特性在开发者中获得了很大的吸引力，并且已经被视为是未来 UIKit 的潜在继任者；Swift for TensorFlow 是一个将谷歌 TensorFlow 框架和 Swift 集成在一起的深度学习和可微分编程（differentiable programming ）平台，开启了 Swift 的全新方向。 02、我们分析了GitHub上5.46 亿条日志，发现中国开源虽然贡献大但还有这些不足… 发布时间：2020-02-02 作者简介：InfoQ 是一家全球性社区网站，基于实践者驱动的社区模式建立，促进软件开发领域知识与创新的传播是 InfoQ 的使命；X-lab 开放实验室是上海同济大学跟华东师范大学联合办的一个创新实验室。 本文通过大量客观数据的罗列，肯定了中国开源对世界的贡献，但也指出了很多不足之处。本文分析的摘要如下。 宏观统计结果。大多数项目处于低活跃、参与人数少的状态。活跃度高和参与人数多的项目的占比都是万分之一级别的。 世界 Top 10 开发者账号。都是机器人，侧面反映出开源自动化流程的强大。 世界 Top 10 项目。大公司以及民间主动发起的项目都有，涵盖前端、容器编排、深度学习以及文档整理等多个领域。 中国 Top 20 项目分析。涵盖前端（几乎占据榜单一半，但缺少核心项目）、后端、教育、求职、人文关怀等诸多领域。 Repo 协作关系。我们可以使用 Git2Net 工具来分析 Commit 生成协作图。 开发语言分析。活跃度上，JS 第一（无需编译，浏览器直接运行），Py 第二（高可读性，应用范围逛，人工智能优先语言），TS 第三（同属于 JS 生态圈）等，相继的是 Java、C++、Go……。 国内技术公司开源项目一览。阿里领衔，各大企业近年来均在不断加大开源社区生态建设。 展望。Github 一定程度上受美国法律制约，中国也需要自己的核心技术。 03、开源的两种局面 发布时间：2020-02-06 作者简介：Mick Brady 是 ECT 新闻网总编辑。 在过去的二十年里，开源软件运动有了巨大的发展，许多曾经认为开源是一种威胁的企业现在意识到了它的价值；但另一方面，有人利用开源进行虚假的营销或宣传，也可能会给一个组织松散的社区带来问题，更大的公司利用这一点来突袭，殖民代码和/或资金基础，然后从内部控制项目。 04、Linux 基金会披露最常用的开源组件及其安全问题 发布时间：2020-02-18 作者简介：Steven J. Vaughan-Nichols 是自由作家，撰写有关技术和技术业务的文章，工作内容已经发表在从高科技出版物（IEEE Computer，ACM NetWorker，Byte）到商业出版物（eWEEK，InformationWeek，ZDNet）再到流行技术（Computer Shopper，PC Magazine，PC World）和 主流媒体（《华盛顿邮报》，《旧金山纪事》，《商业周刊》）上。 根据红帽最新的一份研究表明，开源软件在企业已经占据主导地位。另一份更早的研究发现，开源软件占所有软件的 80%-90%。今天，很多软件或程序是建立在开源组件上的。 Linux 基金会本次发布的 Census Program II 报告向前迈出重要一步，而且提出一种理解和解决开源软件结构和安全复杂性的方法。该方法不仅可以识别应用程序中最常用的自由和开源软件（FOSS）组件，而且能检查它们潜在的漏洞。报告也列出了使用最广泛的软件组件的排名，前三名分别如下。 使用最广泛的非 JavaScript 软件组件前三名：com.fasterxml.jackson.core:jackson-core、com.fasterxml.jackson.core:jackson-databind、com.google.guava:guava。 使用最广泛的 JavaScript 软件组件前三名：Async、Inherits、isArray。 报告的研究对象是一些在基础上很重要，使用最广泛的小型的基础构建块程序。这些程序有时不超过 100 行代码，但却非常重要。报告指出开源组件的几个常见问题包括“程序命名不规范”、“许多开源项目仍归属于单独的开发者账户下”以及“下游开发者对新版本的迁移意愿普遍不大”等。 05、企业开源软件正在创新型公司中成长 发布时间：2020-02-19 作者简介：Sarah Schlothauer 是 JAXenter.com 的助理编辑，她也是 Conditio Humana 的编辑，这是一本关于道德、人工智能和技术的在线杂志。 以前人们通常认为开源只是编程爱好者的爱好，现在开源在企业中得到了广泛的应用。红帽进行了一项国际调查，采访了 950 位IT领导人，了解他们在业务中使用开源代码的情况。调查显示，开源在企业中正在崛起，而专有软件在衰落。到2020年，企业使用的软件只有42%是专有软件，而2019年这一比例为55%。IT主管预计，在两年内，这一数字将进一步下降。 开源软件的四大好处：高质量软件、降低成本、安全和使用云及云本地技术。 开源软件的四大使用领域：安全、云管理工具、数据库、大数据与分析。 06、2019-2020 中国开发者调查报告完整版 发布时间：2020-02-27 作者简介：CSDN 创立于1999年，致力于成为IT技术人交流和成长的家园，为中国IT技术人提供知识传播、在线学习、职业发展等全生命周期服务。 CSDN 通过平台优势，进行大数据分析和一定的问卷调查后推出了这份报告。报告中有关开源的概要如下。 68% 的开发者接触开源的时间在 2-5 年。 42% 的开发者首次接触的开源产品是开发工具及框架。 77% 开发者每周在开源上投入时间不超过 5 小时。 65% 开发者不曾在开源上获得收入。 53% 开发者很少参与开源项目。 开发者最喜欢的开源项目是 Apache。 07、一段话消息 Fintech 开源基金会喜迎新成员。随着银行，资本市场机构和其他机构认识到开放源代码在提高效率、降低成本、减少监管压力等方面的价值，开源解决方案可以帮助金融服务公司加快产品上市时间，同时释放资源专注于提供独特业务价值的创新。[2020-02-04] Linux 5.6 增加了许多令人惊艳的特性。WireGuard、USB4、开源 NVIDIA RTX 2000 系列支持、AMD Pollock 支持、许多新的硬件支持、许多文件系统/存储工作、多路径TCP位最终进入主线、2038 年开始为 32 位系统总结工作、新的 AMD TEE 驱动程序用于开发安全的处理器……[2020-02-09] 微软发布 DeepSpeed 开源库，它通过改善规模、速度、成本和可用性，能够极大地推进大型模型的训练，支持 1000 亿个参数模型的训练。[2020-02-13] Community Leadership Development 日常探讨之：如何吸引运营人员参与开源社区？这是个深刻的问题，开源开发者在维护和推广项目的过程中一定会遇到大量的运营需求，开源社区更是如此。然而“开源”二字只对开发者有极大的吸引力，如何跨界吸引单纯的运营人员参与社区，亦或者其实我们根本不需要单独的运营人员……？[2020-02-14] 近日，有其他用户将以 MIT 协议免费开源的 Playnite 发送至 Steam 上售卖 100 美元（国区 256 人民币），然而这并不侵权。Playnite 是一个一站式游戏启动器，支持多种第三方游戏库，如 Steam、GOG、Origin、Battle.net 和 Uplay。包括游戏仿真支持，为玩家的游戏提供一个统一的界面。Playnite 使用 C# 开发，目前只能在 Windows 中运行。[2020-02-18] Oracle-Google 就 Java 是否应享有版权保护展开的斗争即将开庭 [2020-02-21] GitHub：除非真正需要，否则我们不会删除您的任何内容。“在内容删除政策上保持透明，并尽可能狭隘地限制内容删除，这是联合国言论自由专家向平台提出的建议之一，旨在促进在线内容适度的自由表达，”沃尔默说。“在GitHub，我们两个都做。” [2020-02-21] 左耳朵耗子：二十年前编程环境和氛围与现在有什么不一样？大多数公司的办公电脑都无法访问互联网；在家上网需要拨号，56.6Kbps 的电话传输是你上网能得到的最大速度，一小时 15 元左右；电脑主流配置：32M 内存，2G 硬盘，价格 8000 元左右；程序员的月薪，大城市 3000-5000 元左右，小城市 1000 元左右；主要的编程语言是 C 语言，用 C 写所有端，包括前端；前端、后端、测试、运维，全都是程序员的事，那时应该叫软件工程师；最有技术含量的公司是银行……。[2020-02-21] 一个使用开源固件的 Ebike 自行车。在电动自行车世界中，有两条道路。第一个是本土的套件摩托车，带有来自中国的电动机和控制器；第二个是来自捷安特（Giant）等制造商的预制自行车，带有来自中国的电动机和控制器，速度将是其一半，成本是其三倍。选择是显而易见的，并且走第一条路线还有其他好处，例如使用现在具有开源固件选件的设备。[2020-02-23] 项目01、Rome：一个实验性的 JavaScript 工具链 Rome 包括编译器、linter、格式化程序、bundler、测试框架等等，旨在成为处理 JavaScript 源代码的综合工具。不是现有工具的集合体，并取代许多现有的 JavaScript 工具。所有组件都是自定义的，不使用第三方依赖项。目前是实验阶段。 02、Pytorch：将 PyTorch 用于3D深度学习的函数库 Facebook 近日开源了将 PyTorch 用于 3D 深度学习的函数库 PyTorch3D。Facebook 将这些功能打包成工具包，并提供了运算符、异构批处理功能和模块化可微分的渲染API等，帮助研究人员进行复杂的 3D 神经网络应用研究。 03、Scalar：提升操作巨型 Git 仓库速度 Git 作为版本控制系统的优势很明显，但当 Git 仓库的历史记录过多、跟踪的代码变动过为庞大时，Git 变得难以管理所有数据，导致其运行越来越不顺畅。使用 Git 开发庞大的 Windows 操作系统的微软显得颇有经验：早期使用虚拟文件系统开发 VFS for Git（简称 GVFS），回馈改进了 Git 客户端本身，现在开源了一个无需虚拟文件系统即可支持巨型 Git 仓库的项目，Scalar。 Scalar 是一个使用 C# 编写的 .NET Core 应用程序，通过设置所建议的配置值和运行后台维护来最大程度优化 Git 命令的性能。无论开发者使用什么服务来托管代码仓库，Scalar 都能有效地加速Git 指令。 品牌01、[出版社] O’Reilly O’Reilly Media,Inc. 是世界上在 UNIX、X、Internet 和其他开放系统图书领域具有领导地位的出版公司，同时是联机出版的先锋。从最畅销的《The Whole Internet User’s Guide and Catalog》（被纽约公共图书馆评为二十世纪最重要的50本书之一）到 GNN（最早的 Internet 门户和商业网站），再到 WebSite（第一个桌面 PC 的 Web 服务器软件），O’Reilly Meida,Inc. 一直处于 Internet 发展的最前沿。 02、[网站] InfoQ InfoQ 是一家全球性社区网站，基于实践者驱动的社区模式建立。软件正在改变世界。促进软件开发领域知识与创新的传播是 InfoQ 的使命。为此，InfoQ 致力于提供中立的、由技术实践者主导的会议以及文章、视频演讲和采访等资讯服务，面向 5 至 8 年工作经验的研发团队领导者、CTO、架构师、项目经理、工程总监和高级软件开发者等中高端技术人群，提供中立的、由技术实践主导的技术资讯及技术会议，搭建连接中国技术高端社区与国际主流技术社区的桥梁。 03、[开源组织] 开源社 开源社是由国内外支持开源的企业、社区及个人，依“贡献、共识、共治”原则，所组织的开源联盟，旨在共创健康可持续发展的开源生态体系，并推动中国开源社区成为全球开源软件的积极参与及贡献者。 2017 年，开源社转型成为由纯粹个人成员（类似 GNOME Foundation，Apache Software Foundation）的治理模式组成，并于 2017 年底由全体正式个人成员选举出 7 名理事，组成理事会及执行委员会（下设 9 个工作组：成员发展、基础设施、财务、法律事务、媒体、文案/翻译/设计、线下活动、社区合作、高校合作等），由企业及社区开源专家组成的顾问委员会，以及法律咨询委员会。 荐书《什么是科学》 不能从根本上理解何为科学的民族，无法自信地面对未来。 科学成为推动历史发展的强大动力只是十九世纪以后的现象，科学根源于希腊人对于自由人性的追求，因而是一种十分罕见的文化现象。现代科学起源于希腊科学的复兴以及基督教内在的思想运动，对力量的追求、对自然的控制和征服成为现代科学的主导动机。在数理实验科学的意义上，中国古代并无科学。在博物学的意义上，中国古代有独特且强大的科学传统。 凝果 2020 年 01 月凝果屋动态汇总： 本月新增博文： 《开源爱好者月刊：第 1 期（202001）》 本月开源动态： 开源爱好者月刊 完善 README.md 新增“选刊指南” 发布第二期月刊 本月开源贡献者感谢： @hylerrix @yangdajiang 本刊每月底择机发布，以 Github 为中心、微信公众号（见下图）和语雀为同步平台，任何想法和新内容的推荐欢迎以 Github Issue 的形式进行交流与知识共享。","link":"/blog/2020/02/29/005-osm-002/"},{"title":"开源爱好者月刊：第 3 期（202003）","text":"自 1998 年开源定义诞生以来，开源运动就得到了全球众多开发者的拥护。现在来看，来自世界各地的开发者，共同创造出所有人都能自由使用的工具，是一件多么伟大的事情。正因为软件开发是一项团队运动，必须与其他人合作，当有一群人共同参与时，软件才能够更好地被开发。可以说，开源是当代互联网行业发展的必然趋势。 ——“伊红-美蓝”，开源中国 序言从谷歌搜“Open Source”和百度上搜“开源”可见，疫情面前，开源的势头丝毫不减，每天都有大量的开源新闻和博客发布到网络。小至个体、大至公司，自发的开源社区也为疫情输出了大量的开源项目，保护着更多人的健康。为此，本期开辟了新的“微栏”模块，旨在专注开源的一个基本点，汇总一些代表性动态，小窥社区的大力量。本次的“微栏”主题，便紧跟全球的关注点而产生——“开源与疫情抗击”。 此外，前两期的月刊均得到了“容器时代”公众号的转载，对于这份认可与支持深表感谢。“容器时代”公众号围绕容器技术生态圈汇总前沿技术博文，“容器”也是催化“云计算”与“开源”持续健康发展的核心技术之一，感兴趣的大家可以关注一波。由于更多人的关注，关于“凝果”开源动态月总结模块也将先不收录在这里。 本刊从自身对开源的爱好出发，计划先以每月一刊的形式更新。同时，本刊站在众多巨人的肩上，离开这些或许现在会大不相同。本杂志开源（GitHub: ningowood/open-source-magazine），更多动态，欢迎提交 issue，投稿或推荐你的开源内容。 微栏：开源与疫情抗击 本期微栏关注“开源与疫情抗击”，尝试汇总一些代表性动态，展示国际视野下开源社区对疫情的努力。开源包括开源软件和开源硬件，本次疫情是一场考验开源社区协同效率并突破领域局限的挑战。以下分为三个环节分别介绍。 **有哪些新闻动态？ 开源项目仅用一周时间即可启动3D打印的呼吸机验证原型。[2020-03-19, 原文链接] IBM 发布了与 COVID-19 相关的 Call for Code 活动以及相关的入门工具包。[2020-03-20, 原文链接] 加拿大滑铁卢大学的科学家与人工智能公司 DarwinAI 合作开发了一种开源工具，可以识别胸部 X 射线中 Covid-19 的体征”。[2020-03-23, 原文链接] MIT 一个团队发布了MIT紧急通风器项目，希望为低成本呼吸器发布开源设计，这可能会帮助 Covid-19 患有严重呼吸问题的患者。[2020-03-24, 原文链接] …… 有哪些开源项目？ 世界卫生组织应用程序：全球迫切需要一个官方的 WHO 应用程序来帮助遏制和缓解 COVID-19。该应用程序应支持 WHO 的工作，并应在全球范围内可用，并根据用户的位置，文化和语言量身定制信息。该应用程序还应该对国家需求敏感并尊重隐私。一旦建立，就可以利用该系统来主动检测，尽早做出反应并防止未来的大流行。 CHIME（COVID-19 流行病医院影响模型）：由宾夕法尼亚大学 Penn Medicine 的数据科学家构建的开源应用程序，在线工具使医院可以更好地了解病毒对医院需求的影响。 Locale.ai COVID-19 可视化工具：在全球地图范围内可视化 COVID-19 的所有已知案例，该地图会在新数据可用时提供实时更新。 DXY-COVID-19-Crawler：于 1 月创建，是开源社区对 COVID-19 的最早回应之一，提供数据来源较为可信的 API 接口并无偿开放给非商业目的人士使用。 东京市的 COVID-19 工作组网站：东京都政府创建了一个综合性网站，旨在“让东京居民，在东京设有办事处的公司以及来东京的游客了解当前情况，并采取相应的措施和预防措施”。与许多其他城市不同，东京决定开源其网站。 ……更多可以尝试在 awesome-coronavirus 中寻找。 国际社区如何共建？ 加入 Helpful Engineering 计划 共建开源通风机和负压呼吸器的维基 加入 Facebook 上的开源 COVID19 Medical Supplies 群组 加入 Twitter 上爱尔兰的开源呼吸机项目 加入大流行呼吸机项目 加入 100 万个通风机项目 帮助共同编写《Coronavirus 技术手册》 …… 好文01、开源公司在云中蓬勃发展 发布时间：2020-03-02 作者简介：Matt Asay 是 Amazon Web Services 的负责人，前 Adobe 开发人员生态系统负责人。在加入 Adobe 之前，Asay在开放源代码公司中担任过一系列角色：MongoDB 业务开发，营销和社区副总裁；实时分析公司 Nodeable 的业务开发副总裁（被 Appcelerator 收购）； 移动 HTML5 初创公司 Strobe（被 Facebook 收购）的业务开发副总裁兼临时首席执行官； Ubuntu Linux 公司 Canonical 的首席运营官； 内容管理初创公司 Alfresco 的美洲负责人。 Asay 是开放源代码计划（OSI）的荣誉委员会成员，并持有斯坦福大学法学博士学位，主要研究开放源代码和其他 IP 许可问题。 “开源”可以使我们更加的了解“云计算”。我们已经看到了明确的迹象，表明开源已经脱离了内部部署的根源而走向了云。红帽最近的一项调查发现，95％ 的受访者认为开源很重要，专有软件的使用率从去年的 55％ 下降到了 42％。尽管现在将其称为趋势可能还为时过早，但 28％ 的受访者称“在云中工作”是使用现代开源工具（如Kubernetes）的主要好处。 事实是如此之多，以至于 Gartner 在 2019 年中期准备宣布“云现在是用于管理数据的默认平台”，并且“只有传统兼容性或特殊要求才可以让您在内部办公”。 02、如何成为 DevOps 的合适人选 发布时间：2020-03-16 作者简介：Josh 是 Splunk 的高级技术倡导者，致力于帮助 IT 组织发展以支持对其不断增长的需求。从桌面支持开始，一直到实现企业架构和操作自动化，他已经在 IT 领域工作了 20 多年。在过去的十年中，他最近的工作重点是 DevOps，数字转型和 IT 转型。 Josh 是几本热门书籍的合著者，是一部连续播客，领导了许多技术用户团体，并参与了多个公开演讲。 “婚姻不仅仅是找到合适的人，而是成为合适的人”，这句话很好地提醒了每个人在任何健康关系中应负的个人责任。随着更多组织将 DevOps 用作开发和向客户交付价值的模型，健康关系的影响对于成功至关重要。 从历史上看，开发团队与运营团队之间的关系一直不健康。至少可以说，不良的沟通、有限的同理心和不信任的历史使这些团队合并为更严格的运营模式具有挑战性。而在 DevOps 中，各方必须根据他们如何为他人增加价值来制定自己在组织中的角色。每个人（包括经理和领导者）都可以做一些事情，以成为其 DevOps 关系中更好的贡献者和合作伙伴。 通过学习可以改善心理健康，投资自己并扩大知识面。 DevOps 理想地需要“T 形”人员，这些人员必须对某个主题有深入的了解，并且需要更广泛的系统知识。DevOps 对每个人的要求都更高，其成功与人际关系的健康直接相关。组织的每个成员都应运用这些技术来发展和完善自己。专注于成为团队的合适人选将建立更牢固的联系，并使组织更有能力实现其目标。 03、从开源软件衡量社区健康中吸取的惨痛教训 发布时间：2020-03-25 作者简介：Georg Link 是一位开源战略家，使命是在使用社区指标和分析方面使开源变得更加专业。Georg 与他人共同创立了 Linux Foundation CHAOSS 项目，以推进开源项目运行状况的分析和指标。 Georg 拥有 14 年的经验，曾为多个开源项目做出过积极的贡献，并在 18 多个会议上就开源主题进行了演讲。 Georg 拥有 MBA 和博士学位。在信息技术领域，作为 Bitergia 的销售总监，Georg 帮助组织和社区采用 CHAOSS 指标和技术。 业余时间，Georg 喜欢阅读小说和热气球。 “如果不去衡量，就无法得到改善”——彼得·德鲁克，奥地利的美国管理顾问，教育家和作家，其著作为现代商业公司的哲学和实践基础做出了贡献。 衡量开源社区的健康状况越来越重要。从开源社区形成的那一刻起，研究人员，维护人员和组织就开始尝试了解社区是否健康以及如何使其健康。开源软件社区健康分析（CHAOSS）项目提供了一种了解社区健康的正式方法。该项目于 2017 年开始，将四个利益相关者（开源社区，学术界，组织和工具制造商）召集到 Linux 基金会的保护下。 GrimoireLab 是本文的重点，是 CHAOSS 共同创建的项目之一。 GrimoireLab 有一个有趣的故事，它包含了英雄旅程的所有要素。作者从英雄的出发、启动到回归三步，分享沿途学习的一些经验教训： 使用灵活的数据库架构可以更好地处理数据更改。 管理人员的身份和从属关系是在开源中进行质量分析的关键要素。 如果数据的格式和类型可能发生变化，请不要对可视化数据进行硬编码。 提供一种共享“实时”指标的简便方法。 提供一种简单的方法来探索数据并为其他工具可能需要的数据建立自定义查询。 丰富的数据要将复杂指标由多个指标组合而成。 GrimoireLab 从源自对分析和理解开源项目和社区的渴望出发，通过 Bitergia （共同创建 CHAOSS 的工具制造商）将其从舒适的学术环境带入未知的商业世界，最终获得了 Linux 基金会 CHAOSS 项目的创始项目认可，成为 Linux 基金会创建的快速发展的商业开源生态系统的一部分。 04、Greg Smith 谈开源软件的优缺点 发布时间：2020-03-26 作者简介：Gregory 在轮胎领域的职业生涯始于捷豹路虎（Jaguar Land Rover），他是该公司第一位制造轮胎模型的人。 这导致他成立了 Tyre CAE 和建模团队，负责轮胎测试，建模和技术开发。Gregory 于 2016 年获得了四项专利，并因其在 GS2MF（一种高效的轮胎测试程序）上的博士学位而获得了轮胎技术青年科学家奖。 此后，Gregory 移居美国，与 Goodyear 合作进行虚拟轮胎的提交工作，在那里他致力于开发一种使用虚拟建模技术设计轮胎的流程。 可以从本文看看传统轮胎领域对开源的思考与实践，究竟是什么原因让开源必不可少。 2015 年 4 月，在英国萨里大学举行的第四届国际轮胎学术讨论会上，会议讨论了开源的总体思路。来自商业轮胎模型开发社区的各种人物，使用模型的汽车和轮胎公司的代表以及参与更基础研究的一大批学者出席了会议。从知识产权问题和许可到技术进步，发展战略和培训，一切都引起了问题。归根结底，大多数讨论都集中在两种方法之一： 传统的许可模式。公司或组织开发轮胎模型，对其进行测试，评估，然后在工作时将模型编译到黑匣子中并出售使用许可。这些许可证通常附带一些培训和文档资料，以及持续的维护费用。这样做的好处是许可证费用产生了更多可实现的收入。缺点主要在客户方面–无法看到黑匣子意味着了解模型的唯一方法是通过文档和持续评估。此外，如果客户想要添加功能或修改，则他们通常无法自己添加功能或修改，必须依靠供应商。 支持开源思想。在这里，开发一个相当成熟的软件，然后在线发布源代码。这样做意味着任何人都可以浏览代码并完全了解轮胎模型的功能。其他利益相关者也可以自己开发代码，并鼓励他们共享他们所做的任何更新。如果有足够的用户投资该项目，则整个社区的开发工作都将完成，从而降低了总体开发成本。此外，如果特定用户需要特定的增强功能或其他功能，则他们可以自己开发这些增强功能并与社区共享这些增强功能-客户得到他们所需的东西，并且轮胎模型会不断得到发展。 05、旷视开源：从“复兴”走向“商业化 开源不是我的一时冲动，而是深思熟虑、谋划已久。 ——陶建辉，物联网开源大数据平台涛思数据的 CEO 发布时间：2020-03-27 作者简介：“我思锅我在”公众号：“投资无涯，做一个圈内的局外人”。 AI 独角兽旷视科技副总裁谢忆楠表示开源的目的是：“想让更多人用我们的框架，找到更多能在产业落地的算法和部署的方案”。其中的一些观点如下： 选择开源本质上是个技术方向性问题，不是商业问题，更不能成为一种商业模式。 如果想把一个开源项目（project）做成一款成功的开源产品（product），这才是商业问题。 成功的开源项目背后能持续提供核心支持的往往只是一个精简的团队或一家公司，最多两家。 找到企业级客户，“SaaS”的重点不是“Software”，而是“Service”，正如“云服务”的重点不是云，而是服务。 只有做到以开发者为导向，才能最终做到以客户为中心。 一个在前端经久不衰的开源服务，背后必然有一个具备高度凝聚力和全球化视野的开发团队，以及围绕这个团队而组建的高度商业化运作的公司，这与国别无关。 开源商业化对于初创团队（或处于成长期的公司）与大公司相比，主要有以下几点不同，仅供参考： 出发点不同：大公司可能在一个项目的早期便开源，凭借其号召力希望更多人一起“贡献”迭代，初创团队则会在产品相对成熟的时候再开放，希望尽快吸引用户深度“使用”，注重完善产品在工业环境下的综合表现。 战略意义不同：无论产品还是生态可能仅是大公司商业战略的一环，而对于初创公司产品和用户就是全部。 运营策略不同：因此大公司建立“联盟”（partnership），包括传统软件巨头、咨询公司、ISV（独立软件开发商）、集成商、SaaS 服务商等伙伴，而初创团队更注重维护“开发者社区”（community）。 未来在 AI、基础设施以及 IoT 等前沿领域和相关技术上，我们一定会看到更多国内开源项目及科技巨头的行动。 快讯 世界上第一个开源核反应堆蓝图即将上线。核电在应对气候变化中的作用是一个有争议的话题，但一位硅谷企业家认为，他可以通过发布小型反应堆的开放源代码设计（可以在两年内以仅3亿美元的价格建造）来释放争议。我们可能很快就会发现开源核电是否有优势。[2020-03-02] IBM 2020 “代码召唤”聚焦气候变化和 COVID-19。IBM 的目标是以新的技术，对世界各地的社区产生即时和持久的人道主义影响。77％ 的第一响应者和开发人员同意声明“气候变化是我们这一代面临的最紧迫的问题。[2020-03-10] GitHub 收购 NPM。NPM 是 JavaScript 世界的重要组成部分，对于每天使用公共 NPM 注册表的数百万开发人员而言，NPM 将始终可用且始终免费。展望未来，GitHub 和 NPM 集成在一起可以提高开源软件供应链的安全性，并使开发者能够跟踪从 GitHub 拉取请求到对其进行修复的 NPM 软件包版本的更改。[2020-03-16] Rancher 获 4 千万美元 D 轮投资。在 Kubernetes 起飞之际，这家拥有 6 年历史的初创公司 Rancher Labs 计划利用其新资金继续其“随处运行 Kubernetes”策略。这包括将其引入希望在边缘领域运行 Kubernetes 集群的新市场。[2020-03-16] 怀疑开发者在“造核弹”？GitHub 不断封禁开源项目。继去年封禁伊朗等地区账号后，GitHub 今天再次封禁了一个属于微软的前端开源项目 Aurelia，理由是项目中有两名来自伊朗的外部贡献者。虽然 GitHub 首席执行官致歉表示“这次的确是个错误”，但是开发者们显然不买账：GitHub 封禁项目的行为是否太随意了？这样的行为难道不是与开源信念背道而驰吗？[2020-03-20] 开源社区：现代 GNU / Linux 系统应该支持运行旧游戏。根据 Payne 的说法，这就是为什么自由软件基金会需要利用其“自由来研究和修改”用于现代 GNU / Linux 系统的较早的自由软件游戏。这是将它们带入下一代的唯一方法，因为失去它们就像失去了我们历史的一部分。 IEEE 标准协会启动了开放源代码协作平台。IEEE 标准协会最近为技术社区引入了一个新平台，以就开源项目进行协作。该平台称为 IEEE SA Open，可让独立软件开发人员，初创公司，行业，学术机构和其他机构在协作，安全和负责任的环境中创建，测试，管理和部署创新项目。[2020-03-26] Warren 竞选支持技术将开源。该团队开发了自己的软件来协调志愿者并综合选民数据。他们正在 GitHub 上免费提供七个内部软件项目，GitHub 是网络上开源软件的最受欢迎目的地，希望其他民主党竞选活动可以在他们在竞选活动中开发的基础上发展。[2020-03-27] 苹果招兵买马，或在开源领域有大动作？信息显示，苹果公司正在招聘开源项目工程师（open source program engineer）。回过头来看，苹果极致的保密文化似乎与开源的精神格格不入，那么如此“封闭”的苹果，却开始招募开源人才，是否预示着接下来他们会在开源界有什么动作呢？[2020-03-27] 开源字体是给设计社区的情书。可以自由使用和修改的字体为他人提供了磨练自己的工艺并分享宝贵反馈的机会。[2020-03-28] core-js 作者入狱 18 个月，月下载量过亿的 npm 包或将无人维护。core-js 的作者 Denis Pushkarev 平时除了写程序外，业余爱好就是飙摩托车。前不久他因驾驶摩托车撞人致一伤一亡。根据俄罗斯联邦法律，他被判处有期徒刑 18 个月，剥夺 2 年驾驶权利，另处以罚金 138 万卢布。core-js 是 npm 上最流行的库之一，每月下载量在 105M 次，也就是一亿多次。一共有 19134 个库依赖了 core-js。[2020-03-30] 项目01、first-order-model：“图像动画的一阶运动模型”的论文及源代码 图像动画包括生成视频序列，以便根据驱动视频的运动对源图像中的对象进行动画处理。我们的框架可解决此问题，而无需使用任何注释或有关特定对象的先验信息进行动画处理。一旦接受了一组描述相同类别对象（例如面孔，人体）的视频的训练，我们的方法就可以应用于此类的任何对象。为此，我们使用自我监督的公式将外观和运动信息分离。为了支持复杂的运动，我们使用了由一组学习的关键点及其局部仿射变换组成的表示形式。生成器网络对目标运动期间出现的遮挡进行建模，并将从源图像提取的外观与从驾驶视频获得的运动进行组合。我们的框架在各种基准和各种对象类别上得分最高。 02、automl: 包含与 AutoML 相关的模型和库的列表 只需极少的工作量和机器学习专业知识，即可训练出高质量的自定义机器学习模型。EfficientDet 是由 Google Brain 小组和 Google AI 共同开源的 AI 工具，是 EfficientNet 的下一代版本，可以在不使用任何计算的情况下实现先进的目标检测。EfficientDet 作者表示，现有的缩放目标检测方法往往会牺牲准确性，或者会耗费大量资源。EfficientDet 能以一种低成本、低能耗的方法在边缘或云上部署目标检测，其方法是“同时对所有主干、特征网络和 box/class 预测网络的分辨率、深度和宽度进行统一扩展”。 03、bottlerocket: 用于托管容器的操作系统 Bottlerocket 是用于托管容器的基于Linux的免费开放源代码操作系统。 Bottlerocket 专注于安全性和可维护性，为基于容器的工作负载提供了可靠，一致且安全的平台。这反映了我们在亚马逊上学习构建操作系统和服务的知识。 04、Ledge：DevOps、研发效能知识和工具平台 基于在 ThoughtWorks 进行的一系列 DevOps 实践、敏捷实践、软件开发与测试、精益实践提炼出来的知识体系。它包含了各种最佳实践、操作手册、原则与模式、操作手册、度量、工具，用于帮助您的企业在数字化时代更好地前进，还有 DevOps 转型。 品牌01、[基金会] Apache 基金会 Apache 软件基金会（Apache Software Foundation，简称为ASF），是专门为支持开源软件项目而办的一个非营利性组织。在它所支持的 Apache 项目与子项目中，所发行的软件产品都遵循 Apache 许可证（Apache License）。组织构成中，理事会（Board of Directors）是管理与监督整个 Apache 软件基金会（ASF）的商务与日常事务，并让它们能符合章程的规定下正常地运作；项目管理委员会（Project Management Committees，简称为PMC），主要负责保证一个或者多个开源社区的活动都能运转良好。 02、[代码托管平台] Github GitHub 是通过 Git 进行版本控制的软件源代码托管服务平台，由 GitHub 公司（曾称 Logical Awesome）的开发者Chris Wanstrath、PJ Hyett 和 Tom Preston-Werner 使用 Ruby on Rails 编写而成。截止到 2015 年，GitHub 已经有超过两千八百万注册用户和 5700 万代码库。事实上已经成为了世界上最大的代码存放网站和开源社区。2018 年 6 月 4 日晚上，美国科技公司微软宣布以75亿美元的股票收购 GitHub。 03、[网站] 开源中国 OSCHINA 成立于 2008 年 8 月，是目前国内最大的开源技术社区，拥有超过 300 万会员，形成了由开源软件库、代码分享、资讯、协作翻译、讨论区和博客等几大频道内容，为 IT 开发者提供了一个发现、使用、并交流开源技术的平台。2013 年，OSCHINA 建立大型综合性的云开发平台-码云，为中国广大开发者提供团队协作、源码托管、代码质量分析、代码评审、测试、代码演示平台等功能。 荐书 “人类社会还没有充分理解程序员带来的美和智慧。Graham 的这本书却做到了这一点，描述得清晰又动人，任何愿意倾听的人都会大有收获。如果我们不愿意马上就失去一些重要的东西，那么我们这个社会就应该学会倾听。” —— Lawrence Lessig，斯坦福大学法学院教授 本书是硅谷创业之父 Paul Graham 的文集，主要介绍黑客即优秀程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。本书适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。 订阅本刊每月底择机发布，以 Github 为中心、微信公众号（见下图）、语雀和知乎为同步平台，任何想法和新内容的推荐欢迎以 Github Issue 的形式进行交流与知识共享。","link":"/blog/2020/03/31/006-osm-003/"},{"title":"欲取代绝大多 JavaScript 工具链？Rome 尝鲜","text":"文章缩略图：一个包含希腊斯巴达头盔的罗马项目 Logo 条条大路通 Rome。在 Rome 还没有发布 NPM 正式版之际。我们围绕 JavaScript 工具链为核心点，来看看前往 Rome 的路上都有什么；以及 Rome 本身，意味着什么？ 二月的最后一天，我在为“开源爱好者月刊”搜寻本月最新的开源项目时，偶遇一个名叫 Rome 的仓库霸榜，眼前着实一亮。“一个实验性的 JavaScript 工具链”、“包括编译器、lint、格式化程序、捆绑器、测试框架等”以及“旨在成为与 JavaScript 源码处理相关的所有功能的综合工具”短短几句话展现了一个宏大的目标。现在，是时候入坑了解一波并在个人能力范围内作一个浅要的分享。 Rome 由就职于 Facebook 同时是 Babel 和 Yarn 作者的 Sebastian McKenzie 主导开源，开源之前，Rome 基本是他的个人项目，现在 Facebook 愿意付薪水让他潜心开发。截止现在（2020 年 04 月初），Rome 的提交记录已经从 70+ 到 600+，贡献者拓展到了 40+ 位，产生了 30+ issues 和 170+ Pull Request。 Rome 的 Star 趋势图，发布之初便 3k+ star： 此外，或许也能从侧面呼应我曾在月刊第三期中收录的一句关于“创业公司和大公司开源出发点有何不同”的话：大公司可能在一个项目的早期便开源，凭借其号召力希望更多人一起“贡献”迭代，初创团队则会在产品相对成熟的时候再开放，希望尽快吸引用户深度“使用”，注重完善产品在工业环境下的综合表现。 正文 &amp; 背景 &amp; 干货开始。 Rome：从个人项目到 Facebook 新开源从官网不难看出，Rome 旨在成为与 JavaScript 源代码处理相关的所有功能的综合工具，其中包括“编译器、Linter、格式化程序、捆绑器、依赖管理器和测试框架”等。Rome 源于对整个项目的扩展范围一致性的渴望。 同时，Rome 也来源于 Babel 作者本身对 Babel 的一些不满足而新创，就像 Deno 之于 Node 一样。 Rome 作者 Sebastian 关于 Rome 的推文集： 本节根据 README.md 和官网首页的介绍，来以问答形式展示 Rome 的背景和想要达到具体目标。 01、Rome 的一些来源？ 在计算机科学中只有两件难事：缓存失效和命名。 ——Phil Karlton 立项来源：由 Babel and Yarn 的作者 Sebastian McKenzie 发起，是 React Native 团队的一个项目。 名称来源：因“通向罗马的所有道路”，“罗马不是一天建成”和“在罗马时要像罗马人一样”这样的谚语而得名。 这是指整个项目的扩展范围和对一致性的渴望，它始于一个办公室玩笑。 Logo 来源：一个古希腊斯巴达头盔。虽然它不是罗马字母，也不太相关，但看起来比 Galea （罗马士兵的头盔）酷。 02、Rome 的编码架构？ 在版本控制系统中，monorepo（单声道存储库的音节缩写）是一种软件开发策略，其中许多项目的代码存储在同一存储库中。 截至 2017 年，这种软件工程实践已有十多年的历史，但直到最近才被命名。——Monorepo，维基百科 完全使用 TypeScript 编写，很少使用松散类型。 支持处理 JSX 以及 Flow 和 TypeScript 代码。 self-hosted，可以自己编译自己。 不是现有工具的集合，所有组件都是自定义的，不使用第三方依赖项（对 JavaScript 生态系统进行了重新思考，对整个工具链采用了不依赖第三方库的大胆实现）。 是带有内部软件包的 monorepo 架构以便划定代码边界。 03、Rome 的工作展望？ 旨在成为与 JavaScript 源代码处理相关的所有功能的综合工具。 目标是替代许多现有的 JavaScript 工具，但也将提供为其他工具提供自身的集成方案，以根据需要随意使用——例如使用 Rome 编译器作为另一个捆绑程序的插件。 目前关注的领域是 Linter（用于分析源代码以标记编程错误，bug，样式错误和可疑结构的工具），这是将 Rome 变成最容易使用的工具链的目标里阻力最小的一个环节。 微栏：回看 JavaScript 工具链 在学习一个工具之前，往往我们应该先去了解这个工具可以用来解决什么样的问题；同样的，当我们遇到一个问题的时候，我们也应该带着这个问题去找工具解决。——阿里巴巴集团 高级前端工程师 叶俊星 成熟的软件项目必然遵循的良好的开发规范，也拥有属于自身独特的软件开发生命周期，编程实践只占整个开发周期的很小一部分。当一个 JavaScript 软件被建立时通常还会遇到哪些需要解决的问题？这便涉及到了 JavaScript 项目的技术选型，而 JavaScript 生态圈的明星项目数不胜数，以下作一个纵览，不涉及各个工具的具体使用方式。 JavaScript 工具链示意图： JS 开发环境？有 V8、Node 甚至是 Deno 等； JS 前端框架？有 Angular、React、Vue、React Native、jQuery 等； JS 后端框架？有 Nest、Express、Koa 等； JS 脚手架？有 Vue CLI、Angular CLI、Create React App、Yeoman 等； JS 转译工具？有 Babel 等； JS 测试工具？围绕单元测试、集成测试，有 Mocha、Jasmine、Jest、Karma 等； JS 调试工具？有 Chrome DevTools/Firebug/Webkit inspector 等各大主流浏览器、VS Code/WebStorm 等各大编辑器/IDE 等； JS 格式规范工具？有 JSLint、JSHint、ESLint、TSLint 等； JS 接口联调工具？有 Axios、Fetch 等； JS 包管理器？有 NPM、Yarn、Bower、PNPM 等； JS 模块加载器？有 RequireJS、SystemJS、StealJS、ES Module Loader 等； JS 任务管理工具？Grunt、Gulp、Webpack 监听文件变化，自动执行任务； JS 静态化支持？有 TypeScript、CoffeeScript、Flow、LiveScript 等； JS 代码后处理工具？围绕混淆器、缩小器、优化器诸多领域有各种各样的 loader 等； JS 打包工具？Webpack、Rollup、Parcel、Browserify 等； JS 模板引擎？有 handlebarsjs、etpl、templatejs 甚至各大前端框架内置的模板语法等； JS 非 Web 框架？在物联网、区块链、大数据等领域均有相关库支持，本文不涉及。 JS 进程管理？有 Forever、PM2、StrongLoop Process Manager 等； ……？甚至编辑器、IDE、CSS 预处理器、代码托管平台、团队开发模式(纯前端、重后端、前后分离)、WebAssembly、Serverless、JS DevOps 等都可以加到项目的技术选型范围内。 因此可以看出，技术选型便是针对能让项目成功运转各个环节寻找相应的解决方案；工作流（Workflow）是所有解决方案融合后的落实流程；而工具链（Toolchain）便是工作流下所有实现方式的汇总，同时一个工具也能代表一个解决方案。 简而言之，JavaScript 工具链便是 JavaScript 工程师在开发过程中会用到的一系列工具。 浅尝初试 Rome (v0.0.52)现在 Rome 并没有直接在 Github 上发布任何版本，但编译后生成的 rome.json 可以看出有一个 v0.0.52 的版本号，处于一个很早期的状态，项目简介也是“一个实验性的 JavaScript 工具链”。 想要尝试 Rome，就得从以下步骤逐步展开（由于 Rome 没有发布正式版本，这里无需过多涉及如何整合在 package.json 的脚本中使用等工程化过程）。 帝国时代里的罗马大军： 本章所有 Demo 均在 @hylerrix/demos 的 Rome 文件夹中。 01、git clone rome既然 Rome 没有正式发布版本，我们也无法直接从 NPM 上直接安装 Rome。现阶段，Rome 提供了本地安装的方式，只需要克隆到本地并本地编译和本地 NPM 安装即可使用。 注：安装 Rome 前请确保本地已正常安装 Node 和 NPM 123456789101112# 克隆 Rome 项目到本地$ git clone https://github.com/facebookexperimental/rome# 命令行进入 Rome 项目$ cd rome# 方式一：编译 Rome$ ./scripts/build-release dist# 方式二：编译 Rome（Windows 10 的情况下，使用 PowerShell 7）$ cd rome &amp;&amp; node scripts/build-release dist# 安装编译后的 Rome 到本地全局环境中$ npm install -g ./dist/# 现在便可以使用 Rome 了$ rome # No command specified. Run --help to see available commands. 02、rome initrome init 命令会在当前目录生成一个 rome.json 文件，使用推荐配置会初始化以下内容： 123456{ \"version\": \"^0.0.52\", \"lint\": { \"enabled\": true }} 该文件告诉 Rome 至少应为 0.0.52 版本，以便与当前项目一起使用。具体使用文档还在开发中。 03、rome run index.tsrome run 命令将运行传递给它的任何文件，通常与项目的主文件一起使用。目前仍在开发中，可能无法正确处理所有源文件。此时我们为测试 rome run 成功运行，建立一个 index.ts 和 api.ts 文件，如下。 12345678910111213141516// index.tsimport { getData } from './api'async function setData () { const { success, data } = await getData() console.log('success:', success) console.log('data:', data)}await setData()// api.tsexport const getData = () =&gt; Promise.resolve({ success: true, data: 'Hello World!'}) 此时，运行如下命令便可以成功使用： 1234$ rome run index.ts# ℹ Bundling index.ts# success: true# data: 'Hello World!' 04、rome lint index.ts由于我真的不喜欢在 JavaScript 应用里面写分号，这与主流规范有些不同，所以 rome lint 命令刚好派上了用场：rome 默认需要在 JavaScript 语句结尾写分号。同时在 api.ts 中故意不导出一个 interface 且在 index.ts 中故意将其错误导入，重构后的有错误 index.ts 和 api.ts 以及 rome lint 后执行过程如下： 123456789101112131415161718192021// 故意错误编写的 index.tsimport { getData } from './api'async function setData() { const {success, data} = await getData() console.log('success:', success) console.log('data:', data)}await setData()// 故意错误不导出的 api.tsinterface Params { username: string token: string}export const getData = (params: Params) =&gt; Promise.resolve({ success: true, data: 'Hello World!'}) 123456789101112131415161718192021222324252627282930313233343536373839404142434445$ rome lint index.ts# index.ts lint/pendingFixes ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━# # ✖ Pending fixes# # 1 │ + import {getData, Params} from './api.ts';# │ - import {·getData, Params·} from './api.ts'# 2 │ # .. │ # 4 │ const param: Params = {# 5 │ username: 'hylerrix',# 6 │ + token: 'ningowood',# 7 │ + };# 8 │ + const {success, data} = await getData(param);# 9 │ + console.log('success:', success);# 10 │ + console.log('data:', data);# 11 │ }# 12 │ # 13 │ + await setData();# 14 │ # # index.ts:1:18 resolver/unknownExport ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━# # ✖ Couldn't find export Params in api.ts# # &gt; 1 │ import { getData, Params } from './api.ts'# │ ^^^^^^ # 2 │ # 3 │ async function setData() {# # ℹ However we found a matching local variable in api.ts. Did you forget to export it?# # &gt; 1 │ interface Params {# │ ^^^^^^ # 2 │ username: string# 3 │ token: string# # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━# # ℹ Fixes available. Run `rome lint --fix` to apply.# ✖ Found 2 problems$ rome lint index.ts --fix# ......# ✔ 1 file fixed# ✖ Found 2 problems rome lint 命令在这里提示我们需要加分号并需要在 api.ts 中成功导出 interface。前者可以使用 rome lint index.ts –fix 直接来修理（不会在 api.ts 中添加分号）；后者需要手动修理，但是提供了十分完善的友好提示。 05、rome compile index.tsrome compile 命令将使用一组默认转换来编译文件。由于在开发中，当前此命令没有用于指定转换子集的选项。使用这条命令后，输出的结果已经没有了 interface 的存在。 1234567891011121314$ rome compile index.ts# import {getData, Params} from './api';# # async function setData() {# const param = {# username: 'hylerrix',# token: 'ningowood',# };# const {success, data} = await getData(param);# console.log('success:', success);# console.log('data:', data);# }# # await setData(); 06、rome parse index.tsrome parse 命令将解析文件并输出格式精美的 AST。 12345678910111213141516$ rome parse index.ts# Program {# comments: Array []# corrupt: false# diagnostics: Array []# directives: Array []# filename: 'project-rome/index.ts'# hasHoistedVars: false# mtime: 1_586_498_633_476.8486# sourceType: 'module'# syntax: Array ['ts']# body: Array [# ImportDeclaration {# source: StringLiteral {value: './api'}# namedSpecifiers: Array [# ...... 07、Rome 的更多命令除了官网展示的几个命令外，从源码可以看出还有很多内置的命令正在开发，可以从 rome –help 中寻找答案。 1234567891011121314# 分析并输出文件的依赖$ rome analyzeDependencies index.ts# 把 JavaScript 打包为一个文件$ rome bundle index.ts dist# 启动 Web 服务器$ rome develop# 计算文件路径$ rome resolve index.ts# 安全依赖，运行 Linter 和测试$ rome ci# 运行测试$ rome test# ...restart/start/status/stop/web# ...config/publish/run/evict/logs/rage 参考资料 [English] Rome Github Project [English] Rome, a new JavaScript Toolchain [English] Rome Official Announcement [English] Rome Timeline [English] Facebook Introduces Rome Experimental JavaScript Toolchain [English] 01: Sebastian McKenzie on Babel and the Road to Rome - The Babel Podcast 前端工具链课（一）—— 包管理工具 Rome：Facebook 最新 JS 工具上手 总结 &amp; 订阅经过近几年的蓬勃发展，JavaScript 早已不再局限于“前端开发”的领域中。因此本篇写作的角度并不是仅仅以前端开发为主体探索，而是将 JavaScript 本身抽离出来，这也是自己逐步理清职业发展的一个重要改变。 本文通过学习和写作分享对 Rome 进行了简要的了解，但这还仅仅是入门。自己对 Babel 本身并不熟，还有很多学习过程中产生的疑惑都无法现在进行合适的解答，比如“Rome 和 Babel 的具体异同”、“如何看待 Rome 仓库使用 Git 跟踪 Node Modules”、“Rome 替代现有工具或进行集成方案的具体原理”以及“Rome 的打包流程有何特点”等，挖个坑可以一起交流。 无论最终是否使用 Rome，能引发对 JavaScript 工具链的重新思考也会很有收获。 最后，感谢你的阅读，公众号(@ningowood) 及配套群聊欢迎加入，同时欢迎给如期更新了三期，即将支持线上 UI 界面浏览并提供更多拓展功能的“开源爱好者月刊（@ningowood/open-source-magazine）”仓库点个 Star 吧！（Github 好久没涨粉丝了，也欢迎关注我~）","link":"/blog/2020/04/10/007-javascript-toolchain-rome/"},{"title":"开源爱好者月刊：第 4 期（202004）","text":"序言随着第四期如期发布，三分之一的 2020 年也将宣告结束。本期将继续延续“微栏”的模块，旨在专注开源的一个基本点，汇总一些代表性动态，小窥社区的大力量，逐步为中文社区勾勒出新时代的开源全图谱。 或许我们一直在自嘲，Github 是全球最大的“同性交友网站”——毕竟在较新的 Github 报告中，女性用户只占了 3%。但一定不会没有过这个疑问：在开源中，女性都去了哪里？本期的“微栏”将从这两天最新公布的“2020 杰出开源女性奖”出发，作一期内容整理。或许还是回答不了你脑中越来越多的问题，但相信你一定会找到自己的答案。 本刊从自身对开源的爱好出发，计划先以每月一刊的形式更新。同时，本刊站在众多巨人的肩上，离开这些或许现在会大不相同。本杂志开源（GitHub: ningowood/open-source-magazine），并即将配有一份独特的 UI 界面，更多动态，欢迎提交 issue，投稿或推荐你的开源内容。 PLUS：如果你觉得文章太长，请持续关注“开源爱好者月刊”官方仓库。2020 年 Q2 季度会有不错的 UI 界面正式上线，同时需求也发布在仓库中，欢迎你的贡献。 微栏：初识“杰出开源女性奖” 我们深信开源是技术的未来发展趋势。今天，我们借此机会表彰女性为此项事业做出的杰出贡献，并激励新一代加入到这一伟大的开源运动中。——Red Hat“杰出开源女性奖”介绍 01、什么是“杰出开源女性奖？” “杰出开源女性奖”由 Red Hat （红帽）于 2015 年发起，奖励那些正在为开源做出贡献的女性并照亮她们使之成为其它人的榜样。该奖项包括针对专业人士的“社区奖”和针对学生的“学术奖”两大类别。红帽评审了来自 100 多个社区提交的提名，并在每个类别中选出 5 个人入围，最后开源社区投票选出获奖者。 官网地址：https://www.redhat.com/en/about/women-in-open-source 02、“杰出开源女性奖”的推荐规则？ 寻找在以下方面为开源项目或开源社区做出重要贡献的女性： 代码和编程；品质保障和缺陷类选 (Bug Triage)。 致力于开源硬件。 系统管理和基础架构。 设计、美工、用户体验和营销。 编档、教程和其他传播工作。 翻译和国际化。 开源内容。 社区宣传和社区管理。 知识产权宣传和法制改革。 推广开源理念。 从这里可以看出，开源不只是需要代码上的付出，关于开源的一切贡献，社区都十分欢迎。 03、**2020 年社区奖获奖者：Megan Byrd-Sanicki** 做您想要成为的领导者。当领导力出现真空地带时，每个人都可以主动填补空白。无论是领导他人、领导社区还是仅仅领导自己，开源的每个贡献者都是一个领导者。请不要等待别人给予的授权，要主动创造自己的财富。——Megan Byrd-Sanicki Megan 在创建可持续发展和蓬勃发展的开源社区方面的领导能力使她赢得了 2020 年社区奖。她作为 Drupal 协会的执行董事，通过开发收入模型、引入指导计划以及为具有不同技能和背景的贡献者提供包容性环境，从而建立了一个更强大，更可持续的社区。 通过在 Google 担任开放源代码计划办公室研究和运营经理以及开放源代码计划董事会成员的工作，Megan 与开放源代码社区更广泛地分享了从单个社区中吸取的经验教训，并增强了社区到企业的伙伴关系。Megan 在整个开源过程中一直表现出对贡献者福祉的关心。目前，她参与了 COVID-19 数据建模项目 Covid Act Now 和 FOSS Responders（一种支持开源社区的集中计划）。 更多介绍可以从这篇文章中入手：开源的大门，为每个人敞开。 04、2020 年学术奖获奖者：**Netha Hussain** 相信你自己，知道自己有能力和才能去做自己想做的事情；跟随你的热情，做自己想做的事；未来有时会充满不确定性，但脚下的路总会前行；不断学习新事物。这就是你在专业领域和自身发展中成长的方式。——Netha Hussain Netha 因在 Wikipedia 上公开分享她的医学知识，并增加了与女性相关的话题以及女性的贡献而赢得了 2020 年学术奖。Netha 是一名医生和博士学位、哥德堡大学临床神经科学专业的候选人。她的研究涉及为患有中风的人使用虚拟现实技术。Netha 已为 Wikipedia，Wikidata 和 Wikimedia Commons 用英语和马拉雅拉姆语语言提供了数千种与医疗保健和女性相关的信息。她为印度的妇女和 LGBTQ+ 社区组织了维基百科外展活动。她已将 Mozilla 项目和 TED 演讲翻译成马拉雅拉姆语。她致力于通过知识共享成为解决方案的一部分，这使她目前专注于在 Wikipedia上创建和策划有关 COVID-19 的文章。 更多介绍可以从这篇文章中入手：我是如何被开源赋能，达到百万目标。 05、更多精彩 在 2020 年度，两位“杰出开源女性奖”获奖人的背后，还有八位入围者，和推荐她们入围的各大开源社区领导人等等。想要由点到面，了解更多，欢迎到 Red Hat 的“杰出开源女性奖”官网中了解。 同时不用灰心，这些入围的女性开源贡献者大多在开源领域耕织了 3~10 年，默默期待华裔优秀获奖者早日出现。 好文 每个月优秀的文章数不胜数，本“好文”模块会根据历史内容进行一定的重点节选，并尝试按照推荐度排序。对于原文也没必要全文复述，只作核心摘抄。 01、开源从叛逆回归主流 发布时间：2020-04-02 作者简介：Tom Cassauwers，OZY 网站作者。 开源软件曾具有激进主义的形象。但却越来越成为大型技术的盟友，而非敌人。 30 年前，当 Vicky Brasseur 开始编码时，“开源”一词甚至还没有被发明出来。她参与了诸如 Gutenberg 项目之类的计划，这是当时所谓的自由文化运动的一部分，该运动的目标是使信息自由，并使软件民主。如今，Brasseur不再是边缘活动家或黑客。她是 Juniper Networks 的开源战略总监，该公司是一家拥有 10,000 名员工的美国公司。 Brasseur 体现了当今开源软件运动的巨大变化。“开源”一词曾让人联想起与无面公司竞争的激进分子的形象，OpenOffice 和 Linux 为像微软这样的巨头提供了替代方案。 2000 年，时任微软董事的 Steve Ballmer 甚至批评 Linux 为“共产主义者”；但到了 2016 年，当微软将部分数据库基础架构迁移到 Linux 时，Ballmer 放弃了他的“开源共产主义”立场。两年后的 2018 年，微软以 75 亿美元的价格收购了 GitHub，这是一个开源项目的代码共享网站。 德国软件公司 SAP 的开源专家 Karl Popp 说：“如今几乎没有任何商用产品不使用开源”、 “大多数现代软件和云产品都建立在开源之上”。如今，公司甚至为开源项目提供资金，并允许他们自己的程序员在公司时间内为他们做出贡献。Popp 说：“ SAP通过让我们的开发人员参与其中，向开源项目提供了大量捐款”、 “而且通过这种方式，我们可以与社区合作，因为他们开发软件的速度比一家公司快得多”。Google 是 Linux 基金会的白金会员，每年的价格为 500,000 美元。 对于所有的商业化，开源倡导者 Fogel 说，开源的原始精神仍然存在。他说：“原始的自由软件和开放源代码精神在今天已经变得更加广为人知和信任”、 “每个人都使用数字设备，并且意识到诸如隐私之类的问题。这使我们的思维方式得以蓬勃发展，即我们的工具应该代表我们而不是别人的意思”，公司化开源尚未失去其原则。 02、开源激荡 30 年：从免费社区到价值数十亿美元公司 发布时间：2020-04-22 作者简介：Peter Levine 作为开发人员、企业家和投资者，与开源软件合作已有 30 多年了。他最近发表了一个名为“开源：从社区到商业化”的演讲，该演讲借鉴了他自己的经验以及对数十位开源专家的采访。其中 Peter 跟踪了开源软件的兴起，并提供了一个实用的、端到端的框架来将开源项目转变为成功的业务。 开源起始于边缘活动，活跃于社区，30 年来一路进化，无数的企业在开源项目的基础上拔地而起，今天，开源商业已经迎来了最好的发展机会。没有开源软件，我们的世界就无法运转，至少无法正常运转。 尽管开源运动已经带来了惊人的技术创新，但商业创新对于该运动的成功同样至关重要——特别是近年来 SaaS（Softwars-as-a-Service，软件即服务）行业的兴起，便是开源商业成功的典型案例。根据定义，开源软件自然是任何人都可以使用、修改或分发的软件产品，那么开源商业相比其他软件公司自然也需要不一样的商业模型与市场进入策略。 关于“开源：从社区到商业化”的演讲，Levine 从如下九个角度进行展开： 开源软件复兴正当时 开源的历史：从免费软件到 SaaS 服务 开源生态的良性循环 开源商业成功的三大支柱 选择商业模式 云服务与竞争力优势 进入市场：开源漏斗 成又如何？败又如何？ 开源软件 3.0：开源进入每一家软件公司 03、从 MIT 协议谈契约精神 发布时间：2020-04-25 作者简介：“微月人话”公众号，“简单而深入”。 简单的来说，什么是契约精神——说好的，都写下来，写下来的，我都认。MIT 协议便是写下来的契约、大名鼎鼎的开源软件许可协议 The MIT License，又称 MIT 许可证，是目前 Github 上使用率最高的许可证，第二名到第五名是 Apache 2.0、GPL 2.0、GPL 3.0 和 bsd-3-clause。 适销性 ( MERCHANTABILITY ) 就是说商品一旦售出 ( 虽然可能是免费的 ) ，如果确有问题，就可以退换货，一般来说适销性是缺省的保证 ( 即便没有明示 ) ，法律会支持消费者对不合格产品的退换货权利。但对于AS IS这类商品而言，就是说你觉得不好使也别找我。你觉得根本没法用 ( FITNESS FOR A PARTICULAR PURPOSE ) 也别找我，而且我也不保证我这软件是不是侵权了。MIT协议用了几乎一半的篇幅来说这个，足以见其重要性，这是西方人很强的商品经济意识和法律意识导致的。 04、开源的重要资产是其共同体 发布时间：2020-04-10 作者简介：Sydney Sawaya 是 SDxCentral 的副编辑，内容涵盖云存储，数据管理和云原生。 可以肯定地说，在任何成功的开源项目或产品的背后，都有一个热情而紧密的社区，它们通过透明的方式进行协作，以开发突破传统的服务。在促使组织采用开源方面，文化是推动行业发展和转型的基石之一。 Hightower 表示：“您无法估算全球可用的所有人才”、 “因此，参与或完成任务的唯一方法是尽可能公开和透明，并鼓励人们做出贡献。因此，我认为当我们说开放源代码时，实际上是指封闭源代码的弊端”。 鉴于当今的现代社会及其对更高透明度（可能在很大程度上是对大数据生态系统的回应）的日益增长的需求，再加上竞争异常激烈的业务格局及其对创新的需求，开源技术不仅蓬勃发展而且引起了消费者、公司和政府等的关注也就不足为奇了。 05、从来没有比现在更好的机会来在 Linux 上玩游戏 发布时间：2020-04-24 作者简介：James Mawson 位于澳大利亚墨尔本，每天都在为技术公司开发营销材料。他是计算机、商业和互联网的书呆子，是资深的复古游戏玩家和 Raspberry Pi 黑客，并且是桌面 Linux 的热情推动者。 这篇文章在 opensource.com 上的调研显示，用户在 Linux 上玩游戏的数量超过了在 Windows 上玩游戏的数量，也远远超过了在主机上玩游戏的数量。先不管是否因为调研用户群体本身就是开源的爱好者外，Linux 上玩游戏的趋势也不容小视了。 过去几年最大的改进是可以运行更多的游戏，以及运行它们的难易程度越来越低。这在很大程度上要归功于 Proton——这是一个由 Valve 资助，由 Codeweavers 提供的开源兼容性层。在撰写此文时，Proton 已为 Linux 带来了 6500 多个 Windows 游戏。他们也一直在不断改善它，因此希望这个列表会不断增长。 现在是Linux作为游戏平台大放异彩的时候了。 06、更多文章推荐 [04-01] 开源代码–用户隐私的未来 [04-02] Kubernetes 是否正在成为企业IT的驱动力？ [04-04] Linux 击败 IBM，开源软件将击败 Waymo 和 Tesla？ [04-08] 东太平洋开源的崛起 [04-08] Docker 围绕 Compose Specification 建立开源社区 [04-15] 我们欠开源的 4 项创新 [04-15] 开源之道已被证明是开发软件解决方案的领先方式 [04-17] 汇报 100％ 的代码覆盖率是否合理？ [04-18] 我的 10 个开源社区管理指导原则 [04-20] 为什么我使用开源技术进行 Web 开发 [04-22] 通过开源拯救地球 [04-23] 一起步入新的虚拟世界 [04-23] 您应该外包下一个开源项目吗？ [04-20] 预算中是否包含开源分析？ [04-23] 复制和粘贴代码：如何通过使用开源代码丢掉工作 [04-27] 为修复选举，开源技术可以做的和不能做的 快讯 Mozilla 将资助高达 50,000 美金支持与COVID-19 相关的开源技术项目。该资金是 Mozilla 开放源代码支持计划（MOSS）的一部分，因此，只有根据自由软件基金会或开放源代码倡议获得开放源代码许可使用的项目才能申请资金。[2020-04-02] IBM 向 Outreachy 颁发了第二个价值 $50,000 的“开放源代码社区赠款”，以表彰其致力于为服务不足和代表性不足的少数族裔提供带薪实习的承诺。去年 10 月，IBM 的开放源社区授予了首个季度性赠款，以促进致力于在开放源世界中为妇女，代表性不足的少数民族和服务不足社区提供教育，包容性和技能建设的非营利组织。[2020-04-03] 全球领先的开源解决方案提供商 Red Hat 公司今天宣布，已任命 Paul Cormier 为红帽公司的总裁兼首席执行官。自 2001 年加入 Red Hat 以来，Cormier 的领导才能和愿景推动了重大战略转变，并扩大了公司的产品和服务组合。 Cormier 率先采用了订阅模式，该模式将 Red Hat 从开源破坏者转变为企业技术支柱。十多年来，Cormier 倡导了开放式混合云的愿景，使客户能够灵活、通用、一致地在任何基础设施上的任何位置，从边缘和裸机到多个公共云交付任何应用程序。[2020-04-06] GNOME 基金会与 Endless 一起自豪地宣布，从 4 月 9 日开始，将接受首届社区参与挑战赛的参赛作品，这是一个令人兴奋的新机会，可以提交一个项目，以鼓励初级编码人员参与 FOSS 社区，以帮助确保免费软件在很长的将来可用。个人或团队的最佳参赛作品可获得高达 $65,000 的现金奖励。[2020-04-07] Mapzen 卷土重来。尽管 OpenStreetMap 等开源项目和 Foursquare 等公司都使用了其技术，但开源地图公司 Mapzen 无法维持自身的业务。 Mapzen 最初于 2018 年关闭，但在 Linux 基金会的支持下它有了新的生命。[2020-04-08] 微软和华中大学的研究人员团队开放了 AI 对象检测器（准确地检测和识别照片和视频中的对象）的源代码-公平多对象跟踪（FairMOT），他们声称在公共数据集上以每秒 30 帧的速度优于最新模型。如果产品化了，它可以使从老年护理到安全领域的各个行业受益，并可能被用来跟踪像 COVID-19 这样的疾病的传播。[2020-04-08] FINTECH 开源基金会加入 LINUX 基金会，以扩展和加速整个金融服务业的发展。在 Linux 基金会的领导下， FINOS 将为全球最大的金融服务公司和科技公司之间就涉及台式机互用性，数据建模，合规性等金融科技项目的行业范围内的合作提供论坛。“金融服务组织一直是新技术的快速采用者，其中包括大量的开放源代码，它们已用来扩展市场范围并创造客户价值。对于企业而言，考虑企业开放源代码及其在保持稳定的同时促进创新的能力变得越来越重要。”高级副总裁兼首席技术办公室 Chris Wright 说道。[2020-04-09] Verizon 推出开源大数据冠状病毒搜索引擎 Vespa。如此多的疾病，如此之多的数据，如此之短的时间。 为了帮助理解冠状病毒的研究。[2020-04-13] MindsDB 为开源自动化机器学习平台筹集了 300 万美元，该平台使数据科学家和开发人员能够快速训练和部署模型。这笔300万美元的融资由OpenOcean牵头，OpenOcean的普通合伙人Patrik Backman是联合创始人，分别是受欢迎的开源项目MariaDB和MySQL的产品负责人。 [2020-04-16] Linux 基金会亚太区与开源中国达成战略合作，共同推动中国开源人才培养。启动仪式上展示了最新的开源技术培训和认证教育资源，以及宣布一系列推广计划和合作伙伴计划，让中国开发者与世界同步。[2020-04-24] A2Z Market Research 最近添加了开源软件市场报告，该报告有助于做出明智的业务决策。该报告旨在包括参与研究的每个地区和国家的全球开源软件市场的定性和定量方面。该报告还提供了有关重要方面的详细信息，例如定义市场未来增长的关键驱动因素和制约因素。它还对公司资料，类型和应用程序进行了分类。[2020-04-25] 项目01、Theia：一个 VS Code 的竞品 Eclipse 基金会执行董事 Mike Milinkovich 在一份声明中说：“Visual Studio Code 是世界上最受欢迎的开发环境之一。 Theia 不仅允许开发人员安装和重用 VS Code 扩展，它还提供了可扩展的适应性平台，可以针对特定用例进行量身定制。” 02、Kiwi：支持 Android 拓展的浏览器 Kiwi 是支持 Android 扩展的浏览器之一。该应用还通过添加暗模式的自定义实现并通过底部栏界面的另一种外观进行了创新，该界面看起来很像 Google 在此设计上的早期尝试。开发人员决定将软件开源，以便与有兴趣构建基于 Chromium 的浏览器的其他人分享这些成就。 03、Jitsi Meet：安全，简单和可扩展的视频会议 Jitsi Meet是一个开源（Apache）WebRTC JavaScript 应用程序，它使用 Jitsi Videobridge 提供高质量\\安全和可扩展的视频会议。Jitsi Meet 客户端在浏览器中运行，而无需在计算机上安装其他任何东西。Jitsi Meet 可以实现非常有效的协作，用户可以流式传输其桌面或仅某些窗口，还支持使用 Etherpad 进行共享文档编辑。 品牌*01、[公司] *谷歌开源 以下内容节选自《Google 教你如何“做”开源》 Google 对于开源的理解，在业界是独树一帜的。从 2005 年就成立了开源项目部（OSPO），并由业内对开源有深刻理解的 Chris DiBona 来主持工作。Google 或许并不是贡献代码最多的公司，在 Kubernetes 项目之前，Google 的开源项目甚至是只有很小的贡献率、或者是强约束并非完全的开放（比如，Chrome 和 Android），但是它依旧在开源开发者圈具有强大的影响力（甚至有人说是最大的），这就是一旦彻底开放如 Kubernetes 这样的平台，就促使这个项目异常的成功。再说了，Google 除了项目之外，还创建过 Google Code，曾经一度是开源软件最大的代码托管的地方，以及大名鼎鼎的 Google 代码夏令营（GSoC），虽然这些举措 Google 都没有大量的代码贡献，但是它促使世界各地的开发人员能够合作，从而编写更多的代码。 除此之外，Google 也通过诸如软件自由保护、 Apache 软件基金会以及其它的组织来对开源项目和社区进行赞助。 同时，Google 也是开源的受益者，从 1998 年最初的服务上线，Google 的产品和服务都是架设在 Linux 等开源软件的基础之上的。当然 Google 是一家广告公司，至少不是一家纯粹的靠软件来盈利的公司，拥有非常多的优秀的计算机科学家和工程师，一如 Google 自家博客中介绍中所说：“从支撑服务的 Linux 内核到内部的文化，开源是 Google 做任何事都绕不过的”。 *02、[公司] *Red Hat Red Hat 是全球最大的开源企业，通过开源项目构建和支持开源产品。回馈所参与的项目和社区，保护开源许可，通过开源帮助客户取得成功。Red Hat在 20 多年前就已加入开源社区。从 20 世纪 90 年代的 Linux 到 Apache，再到 Kubernetes 和云原生计算基础，加入了数百个开源社区和贸易团体。 Red Hat 名下管理着“CentOS”、“Ceph”、“OKD”、“Project QUAY”、“Pulp” 和 “WildFly”等多个明星项目。 *03、[组织] *中国开源软件推进联盟 中国开源软件推进联盟（英文全称：China OSS Promotion Union，英文缩写：COPU，以下简称”联盟”）是在政府主管部门指导下，由致力于开源软件文化、技术、产业、教学、应用、支撑的企业、社区、客户、 大专院校、科研院所、行业协会、支撑机构等组织自愿组成的、民主议事的民间行业联合体，非独立社团法人组织。在2004年7月22日于北京成立。 联盟的宗旨是为推动中国开源软件（Linux/OSS）的发展和应用而努力；为促进中日韩以及中国与全球关于开源运动（Linux/OSS）的沟通、交流与合作而努力；为促进全球开源运动（Linux/OSS）做出贡献而努力。联盟的作用是为推动Linux/OSS的发展，充分发挥联盟在政府与企业之间有关立法、政策、规 划和环境建设方面的桥梁、纽带与促进作用；充分发挥联盟在企业与用户、企业与企业、企业与社区、中外企业/社区间、企业与科研、教育、支撑机构之间关于研 发、生产、教育、培训、测试、认证、标准化、应用等方面沟通、交流、合作、推进的桥梁、纽带与促进作用。 荐书 《社区运营的艺术（第2版）》适合有志做社区、正在做社区，或者对社区有兴趣的人阅读。 社区是个有趣的网络词汇。近年来，这个词多了很多意味。社区不再是慈善组织与和睦邻里的专属词，而是扩散到技术人员、商业人士、政府官员以及任何能上网的人，甚至成为一种营销方式、公司形式。那么，到底如何才能在自己的行业中建立和运营一个活跃、有影响力的社区呢？《社区运营的艺术（第2版）》的作者用自己多年经验和教训试着给读者提供一些参考，包括如何建立战略规划、如何进行有效的沟通、如何创建简单易用的流程、如何运用社交媒体扩大社区的影响力等，在书中最后还对一些知名的社区领袖进行了采访，帮助读者窥探顶级社区成功的奥秘。 没错，这里提到的“社区”，完全可以是开源社区。 订阅本刊每月底择机发布，以 Github 为中心、微信公众号（@ningowood）、语雀和知乎为同步平台，任何想法和新内容的推荐欢迎以 Github Issue 的形式进行交流与知识共享。","link":"/blog/2020/04/30/008-osm-004/"},{"title":"Hello，从多样化安装到简单实战","text":"《Deno 钻研之术》系列于 Deno v1 正式发售之日全新推出，每周不定期更新在 Github 中（https://github.com/hylerrix/deno-tutorial）。让我们一起循序渐进学 Deno，先易后难补 Node，面向未来开发属于自己的 Deno Web App。欢迎订阅，欢迎交流。 学习 Deno 的 N+ 种理由时隔 Deno 开源两年整，万众期待的 Deno v1 正式版今日正式登场。或许你已经听过 Deno 的大名、或许你在项目中已经大量使用 Deno 作者的上一个明星项目 Node.js，亦或许今天才刚刚接触这一切…总之现在上车，背后是业界多年 Web App 开发经验的累加，面前是一片充满未知与惊喜的 Deno 蓝海。 简单的介绍 Deno？Deno 是一个基于 Chrome V8 引擎开发的一个安全的 JavaScript 和 TypeScript 运行时，底层由 Rust 语言编写（最初选型为 Go），发起人是 Ryan Dahl。Ry 也是 Node.js 的发起人，当 Ry 将 Node 交付给社区一段时间后回看 Node 的现状，提出了很多无法忽视的缺陷，于是带来了全新的项目，Deno。 正是 2011 年左右 Node.js 的出现，将 JavaScript 正式带入服务端应用开发领域；也通过彼时领先的模块化思想，促进了 Web 前端工程化的火速发展。同时验证并促进了 Atwood 定律的发展——任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写。 雨后春笋，纵使如今在 Node.js 上构建的各大基础设施（开源库、框架、脚手架等）支撑着从创业公司到各大主流互联网公司的数以万计的核心业务发展，但在 Node 本身不那么容易抛开的历史包袱下，新生的 Deno 依然拥有着很多前瞻性的理念，比如： 底层使用 Rust 语言开发：有很多 Rust 的优良特性支持； 原生支持编译 TypeScript 语言：无需额外进行繁琐的手动配置； 核心标准库维护在 Deno 自身中：无需纠结在各大第三方库中如何选型的同时无需担心这些库的无保障维护问题； 独特的安全沙箱支持：默认情况下脚本不具有读写权限，需要授权； 尽可能地支持 Web 标准：无需更多的手动配置，绝大部分功能开箱即用； 支持 ES 模块标准：无需再承担 Node.js 的 CommonJS “历史包袱”； 重新设计的包管理器：抛弃繁重的 Node Modules，甚至可以很方便地从 URL 中导入模块； 重新思考 package.json：让逐渐庞大的 package.json 能得到合理的“释放”； 原生支持 JSDoc：并将其用于内置的文档系统； 更好的工具链支持：开发者真的不想再忙于各种配置过程之中了； 内置监视文件功能：让热更新更加方便简单。 这就是 Deno，一个令人激动的项目。更多具体的知识点，会在本系列后期逐步展开。 下方 Deno 知识体系示意图的截图来自基于机器学习的信息抽取和检索系统 Magi.com，“它能将任何领域的自然语言文本中的知识提取成结构化的数据，通过终身学习持续聚合和纠错，进而为人类用户和其他人工智能提供可解析、可检索、可溯源的知识体系”。图中内容仅供参考。 优秀的生态，Star 量破 50k+在 Star History 网站上，我们可以看到这两年来社区对 Deno 的关注度稳增不减。从发布一个月多便接近 20k+，到现在已经达到了 50k+ 的 Star 数量，这意味着 Deno 已经跻身 Github 项目全球排行榜至少前 70 位。 截止目前，诞生两年的 Deno 贡献者数量达到 270+ 位，有 3k+ 的 commit、416/1920 的 issues 解决比例和 42/3273 的 PR 解决比例（2020-05-12）。与此同时，诞生近十年的 Node 有 2690+ 位贡献者，30k+ 的 commit、977/11585 的 issues 解决比例和 316/21192 的 PR 解决比例。 下图即为 Deno 目前的 Star History 趋势图。 押宝 Deno？关于为什么学习 Deno，每个人都会有自己的理由。社区中有一种有趣的声音：学习 Deno 是一种“押宝”，希望通过学习 Deno 能彻底放弃 Node 并在未来通过 Deno 获得更好的编程机会。 实则 Deno 还是处于早期阶段，且 Node.js 的成功是有时代背景选择而不可复制。因此将所有学习重心都押宝在 Deno 上尚且过早。 那么如何对待 Deno？Deno 是在开源社区的“礼物文化”环境下诞生的，我们一起将 Deno 看成是加入大家庭的新生命，一起从整个 Web 领域的进程中取长补短共同建设 Deno，才是现阶段对待这份“礼物”最好的状态。 要知道，从 Node 到 Deno，其中有太多的中国开发者的积极贡献融入其中。 只是为了好玩以 Ecma 成员名义发起，阿里巴巴、腾讯等公司领衔的最新《Node.js 开发者 2020 年度报告》中指出，越年轻的同学越关注 Deno。因此，这里着重引用一位年轻的谷歌华人实习生，Deno 核心贡献者之一的 @kevinkassimo 的一句话来看，为什么学习 Deno？ 平心而论，我最初参与的主要目的其实最早是想着“我一直在用 Node 但不了解它真实背后的工作原理”，所以最早看到 Deno 的时候在想“了解 Node 原理的比较好的一个方法是干脆自己去做一个新的 Node”。——@kevinkassimo 这也正是我对于 Deno 的重要心态。大学初入校园期间正值 Node.js 最火的时刻，自己因为对 Node.js 的喜欢选择了大前端领域，接下来的几年也参加、举办过很多前端相关活动，但对于 Node.js 的了解因为自己的身份局限一直没有得到更好的突破。 毕业这一年来看，Node.js 已经发展出一个十分庞大的生态，我们畅游其中能找到大量解决自身编程需求的 NPM 库——这也更显示出自己对于 Node.js 的熟悉差距越来越大。现在 Deno 崭新一片，为了更好的了解 Deno，包括了解 Node.js，更包括跟上整个 Web 的发展进程，我也开始了我的 Deno 之旅。 同时，另一个更大的心态就像 Linux 之父 Linus Torvalds 的自传名一样，“只是为了好玩”。在自身于职场负责的各种各样前端业务外，出于好玩的心态，出于尝鲜的心态，出于一种“Uncharted（神秘海域）”的心态，开启了这一切。 那么：你，为什么学 Deno？ Deno 在 MacOS 上的多种安装方式在开发者群体中，除了最常见的 Windows 操作系统外，Linux 和 MacOS 环境也占重大的比重。Deno 的安装方式在各个平台都有相关的解决方案，本节包括以后所有章节均将默认在 MacOS 上学习 Deno，未来可能会涉及在 Linux 云服务器上部署 Deno Web App。 因此如果你的操作系统是 MacOS，那很方便通过本文进行实战学习。如果你的本地环境是 Linux 或者 Windows，除了一些包管理器的不同、安装目录的不同、环境变量的配置方式不太相同外，并不会阻止你深入学习 Deno 的脚步。可以根据自身操作系统来在 Deno 官方、Deno 社区或者《Deno 钻研之术》系列仓库的 issues 区进行搜寻、讨论 Deno 的其它多种安装方式。 从命令行安装一个软件包需要注意什么？当然是该软件包是否安装成功、安装的过程有哪些日志、是否能运行成功、是否简单配置来升级和卸载……基于这个角度，以下的安装方式会选取 deno -V 来验证是否安装成功（产生了个 idea：“命令行安装软件检查清单”，有趣）。 本节内容专注安装过程，更加深入的安装原理篇未来会有所涉及，正式开始吧！ 安装方式 1：使用 curl 直接安装 curl 在命令行或脚本中用于传输数据。这里，第一种安装方式便是通过 curl 下载远程的安装脚本 install.sh 中的 deno.zip 压缩包到本地并立即执行，如下。 1234567891011$ curl -fsSL https://deno.land/x/install/install.sh | sh# ######################################################################## 100.0%-#O#- # # ######################################################################## 100.0%# Archive: /Users/${USER_NAME}/.deno/bin/deno.zip# inflating: deno# Deno was installed successfully to /Users/${USER_NAME}/.deno/bin/deno# Manually add the directory to your $HOME/.bash_profile (or similar)# export DENO_INSTALL=\"/Users/${USER_NAME}/.deno\"# export PATH=\"$DENO_INSTALL/bin:$PATH\"# Run '/Users/${USER_NAME}/.deno/bin/deno --help' to get started$ deno -V# zsh: command not found: deno 此时安装便成功了一半。从安装成功后的终端日志可以看出，Deno 成功安装在了用户的 ~/.deno 下，并且进入这个目录可以看出里面只剩下二进制软件 ~/.deno/bin/deno，解压前的 deno.zip 已被删除。接下来输入 deno -V 并不能运行成功 deno 命令，需要我们手动配置环境变量来让终端知道 deno 命令该在哪执行。 注意：${USER_NAME} 是你在自己操作系统下的用户名，需要手动改为自己的用户名。 根据日志提示，执行如下命令后，输入 deno -V 便能看出 deno 命令已成功配置。 12345678$ export DENO_INSTALL=\"/Users/${USER_NAME}/.deno\"$ export PATH=\"$DENO_INSTALL/bin:$PATH\"$ deno -V# deno 1.0.0-rc2$ which deno# /Users/${USER_NAME}/.deno/bin/deno$ echo $PATH# /Users/${USER_NAME}/.deno/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/... 这里安装到的 Deno 版本是 1.0.0-rc2，截止 2020-05-13 早上最新的版本是 1.0.0-rc3，让 Deno 自更新版本的命令如下。 123456$ deno upgrade# Checking for latest version# Version has been found# Deno is upgrading to version 1.0.0-rc3# downloading https://github.com/denoland/deno/releases/download/v1.0.0-rc3/deno-x86_64-apple-darwin.zip# downloading https://github-production-release-asset-2e65be.s3.amazonaws.com/133442384/... 安装方式 2：从 Homebrew 中安装 如果你刚才通过 curl 已经将 Deno 安装成功了，现在想尝试 Homebrew 的安装，可以根据已知的 deno 目录和环境变量值，手动卸载 deno，确保相关目录（~/.deno）和相关环境变量（export -p | grep deno 来验收）都清空。 12# 安装 Homebrew$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 现在我们来使用 MacOS 上最知名的包管理器之一 Homebrew 来安装 Deno。由于 Homebrew 默认每次执行都会自动检查更新，显示超慢的 Updating Homebrew…，还不显示具体进度，需要先临时关闭 Homebrew 自动更新后正式安装 Deno。 12345678910111213141516$ export HOMEBREW_NO_AUTO_UPDATE=true$ brew install deno# ==&gt; Downloading https://homebrew.bintray.com/bottles/deno-0.42.0.catalina.bottle.tar.gz# ==&gt; Downloading from https://akamai.bintray.com/b4/b4f91dd079eee18b85b157bb03b1535935a37d9fb6f078e271a7b48b2afd34ea?__gda__=exp=15# ######################################################################## 100.0%# ==&gt; Pouring deno-0.42.0.catalina.bottle.tar.gz# ==&gt; Caveats# Bash completion has been installed to:# /usr/local/etc/bash_completion.d# zsh completions have been installed to:# /usr/local/share/zsh/site-functions# ==&gt; Summary# 🍺 /usr/local/Cellar/deno/0.42.0: 9 files, 41.4MB# ==&gt; `brew cleanup` has not been run in 30 days, running now...# Error: Permission denied @ apply2files - /usr/local/lib/node_modules/expo-cli/node_modules/.bin/detect-libc 从如上终端日志和 https://formulae.brew.sh/formula/deno 中可以看出，Homebrew 上的 Deno 最新版不支持 deno-v1.0.0-rcx 版，只支持 0.42.0。且 Homebrew 会将 Deno 软件放置在 /usr/local/Cellar/deno 下，并在 /usr/local/bin 中自动更新了环境变量。 1234567$ deno -V# deno 0.42.0$ which deno# /usr/local/bin/deno$ ll /usr/local/bin/deno# lrwxr-xr-x 1 ${USER_NAME} admin 30B May 13 10:53# /usr/local/bin/deno -&gt; ../Cellar/deno/0.42.0/bin/deno 安装方式 3：从 ASDF 中安装 ASDF 的体验还不错，ASDF 是可扩展的版本管理器，支持 Ruby、Node.js、Elixir 和 Erlang 等，我们可以通过 ASDF 来安装 Deno，包括进行快速的管理 Deno 的多版本。首先安装 ASDF，可以使用通过 Git 安装并手动配置环境变量，也可以通过 Homebrew 来安装。 1234567891011$ brew install asdf# ==&gt; Downloading https://github.com/asdf-vm/asdf/archive/v0.7.8.tar.gz# Already downloaded: /Users/${USER_NAME}/Library/Caches/Homebrew/downloads/34d73b51ece171e6c4ffe51147d4599c5b7f78749b379dec98ab7dd9174bd595--asdf-0.7.8.tar.gz# ==&gt; Caveats# Bash completion has been installed to:# /usr/local/etc/bash_completion.d# # zsh completions have been installed to:# /usr/local/share/zsh/site-functions# ==&gt; Summary# 🍺 /usr/local/Cellar/asdf/0.7.8: 104 files, 219.6KB, built in 18 seconds 以上需要安装 Deno 前先配置 deno 的 asdf 地址。ASDF 可以很方便的进行 Deno 多版本控制。 1234567891011$ asdf plugin-add deno https://github.com/asdf-community/asdf-deno.git$ asdf plugin list --urls# deno https://github.com/asdf-community/asdf-deno.git$ asdf install deno 1.0.0-rc3# /Users/${USER_NAME}/.asdf/plugins/deno/bin/install: line 27: [: 100-rc3: integer expression expected# ∗ Downloading and installing deno...# Archive: /Users/${USER_NAME}/.asdf/installs/deno/1.0.0-rc3/bin/deno.zip# inflating: /Users/${USER_NAME}/.asdf/installs/deno/1.0.0-rc3/bin/deno# The installation was successful!$ which denodeno not found 可见，通过 ASDF 已经成功安装 Deno，但需要创建软链接，即绑定环境变量。 1234567891011121314151617# 创建软链接$ ln -s /Users/${USER_NAME}/.asdf/installs/deno/1.0.0-rc3/bin/deno /usr/local/bin$ deno -V# deno 1.0.0-rc3$ which deno# /usr/local/bin/deno$ ll /usr/local/bin/deno# lrwxr-xr-x 1 ${USER_NAME} admin 50B May 11 18:37# /usr/local/bin/deno -&gt; /Users/${USER_NAME}/.asdf/installs/deno/1.0.0-rc3/bin/deno# 全局配置 Deno 版本$ asdf global deno 1.0.0-rc3# 在当前目录下设置 Deno 版本$ asdf local deno 1.0.0-rc3# 查看所有可以安装的 Deno 版本$ asdf list all deno# 查看当前 Deno 版本$ asdf current deno # 1.0.0-rc3 (set by /Users/${USER_NAME}/.tool-versions) 安装方式 4：从源码中安装由于篇幅所限，从源码中安装可以引申出很多知识，本文先不涉及，未来会有所更新。 该选择怎样的安装方式？ 基于自身所要使用的操作系统和想要学习 Deno 的方式，从“命令行快速安装”、“包管理器单版本安装”、“包管理器多版本安装并控制”、“源码上安装”等角度决定不同安装方式即可。 Deno 的简单实战准备一个 Hello World 程序Brian Kernighan 于 1978 年写了一本名叫《C 程序设计语言》的编程书，该书中第一次引用了 Hello World 程序，这个传统便被传承至今。在此，关于 Deno 的第一个程序也可以从 Hello World 开始。 因为 Deno 内置 TypeScript 运行时，这里的示例便是官网提供的 welcome.ts，具体如下。 1234567891011// welcome.ts// 从 URL 上导入 server.ts 模块，并提取（ES6 解构赋值）出 serve 对象import { serve } from \"https://deno.land/std/http/server.ts\";// 实例化一个 serve 对象const s = serve({ port: 8000 });// 在终端上打印程序监听的端口地址console.log(\"http://localhost:8000/\");// 使用 ES9 新特性 for await 语法，当访问监听端口时，返回一句“Hello World”for await (const req of s) { req.respond({ body: \"Hello World\\n\" });} 如果如上的 welcome.ts 能成功在 Deno 中直接运行成功，说明了什么？短短的几行代码，便能看出 Deno 自身提供官方标准库（解决了寻找对比学习第三方库的成本），Deno 的模块可以从 URL 上直接导入（独特的导入方式），Deno 支持最新的 ES 标准（不用忙于配置各种 ES6+ 语法的转移器），Deno 内置 TypeScript 运行时（无需手动安装配置 TypeScript 转移器）。 Hello World现在来执行 welcome.ts，由于代码中引入了远程的 server.ts，server.ts 由引入了其它文件，deno 现在会统一下载到全局目录上并执行文件。 123456789101112131415161718192021222324252627$ deno-tutorial git:(master) deno run --allow-net demos/welcome.ts# Compile file:///Users/${USER_NAME}/WorkSpace/Hylerrix/deno-tutorial/demos/welcome.ts# Download https://deno.land/std@0.50.0/http/server.ts# Download https://deno.land/std@0.50.0/encoding/utf8.ts# Download https://deno.land/std@0.50.0/io/bufio.ts# Download https://deno.land/std@0.50.0/testing/asserts.ts# Download https://deno.land/std@0.50.0/async/mod.ts# Download https://deno.land/std@0.50.0/http/_io.ts# Download https://deno.land/std@0.50.0/io/util.ts# Download https://deno.land/std@0.50.0/path/mod.ts# Download https://deno.land/std@0.50.0/path/win32.ts# Download https://deno.land/std@0.50.0/path/posix.ts# Download https://deno.land/std@0.50.0/path/common.ts# Download https://deno.land/std@0.50.0/path/separator.ts# Download https://deno.land/std@0.50.0/path/interface.ts# Download https://deno.land/std@0.50.0/path/glob.ts# Download https://deno.land/std@0.50.0/path/_constants.ts# Download https://deno.land/std@0.50.0/path/_util.ts# Download https://deno.land/std@0.50.0/fmt/colors.ts# Download https://deno.land/std@0.50.0/testing/diff.ts# Download https://deno.land/std@0.50.0/path/_globrex.ts# Download https://deno.land/std@0.50.0/async/deferred.ts# Download https://deno.land/std@0.50.0/async/delay.ts# Download https://deno.land/std@0.50.0/async/mux_async_iterator.ts# Download https://deno.land/std@0.50.0/textproto/mod.ts# Download https://deno.land/std@0.50.0/http/http_status.ts# Download https://deno.land/std@0.50.0/bytes/mod.ts 此时打开 localhost:8000 提示成功。 Deno 的更多实战未来持续更新在《Deno 钻研之术》开源电子书仓库中。 参考资料 Deno 运行时入门教程：Node.js 的替代品 https://star-history.t9t.io/ magi.com 《狼书：更了不起的 Node.js》 deno-1-0-what-you-need-to-know https://gitstar-ranking.com/ Node.js 开发者 2020 年度报告 Hello World 程序的起源与历史 https://curl.haxx.se/ 订阅 &amp; 待续本文属于《Deno 钻研系列》的基础篇，未来计划逐步展开添加的章节并填充更多的文章，如： 基础篇：循序渐进学 Deno 基础知识； Node 篇：先易后难补 Node 知识，探索与 Deno 的异与同； Rust 篇：探索 Deno 底层有关 Rust 的更多知识； 前端篇：探索 Deno Web 前端应用开发的方式； 后端篇：探索 Deno Web 后端应用开发的方式； 架构篇：深入到 Deno 底层读 v8，学架构。 欢迎订阅，一起成长，敬请 Star, Watch &amp; Issue 开源仓库《Deno 钻研之术》！三连一下。 https://github.com/hylerrix/deno-tutorial/ https://github.com/hylerrix/deno-tutorial/ https://github.com/hylerrix/deno-tutorial/","link":"/blog/2020/05/13/009-hello-deno-tutorial/"},{"title":"Deno 入门手册：附大量 TypeScript 代码实例","text":"原文地址：The Deno Handbook: A TypeScript Runtime Tutorial with Code Examples 原文作者：Flavio Copes 原文发布时间：2020-05-12 译者：hylerrix（韩亦乐）, Yunkou（寇云） 校对者：hylerrix（韩亦乐） 备注：本文遵循 freeCodeCamp 翻译规范，同时本文会收录在《Deno 钻研之术》的翻译篇中。 备注：非营利组织 freeCodeCamp.org 自 2014 年成立以来，以“帮助人们免费学习编程”为使命，创建了大量免费的编程教程，包括交互式课程、视频课程、文章等。线下开发者社区遍布 160 多个国家、2000 多个城市。我们正在帮助全球数百万人学习编程，希望让世界上每个人都有机会获得免费的优质的编程教育资源，成为开发者或者运用编程去解决问题。搜索关注微信公众号 “freeCodeCamp”，可了解更多信息。 我每周都在探索新的项目，很少会有一个像 Deno 这样的项目让我如此着迷。 在本手册中我想要让你快速入手 Deno。我会将其与 Node.js 进行对比，然后助力你在 Deno 上搭建第一个 REST API Demo。 目录 什么是 Deno？ 为什么是 Deno？为什么是现在？ 你应该学习 Deno 吗？ Deno 将取代 Node.js 吗？ 一流的 TypeScript 支持 与 Node.js 的异同 不再有包管理器 安装 Deno Deno 命令 你的第一个 Deno 应用 Deno 代码实例 你的第一个 Deno 应用（深入版） Deno 安全沙箱（Sandbox） 格式化代码 标准库 另一个 Deno 示例 Deno 是否有 Express/Hapi/Koa/*？ 示例：使用 Oak 构建 REST API 更多内容 花絮 结语 此外，你可以在此处获取此 Deno 手册的 PDF / ePub / Mobi 版本。 什么是 Deno？如果你熟悉流行的服务器端 JavaScript 运行时 Node.js，那么 Deno 就像 Node.js 一样，但却在很多方面都得到了深刻改善的全新 JavaScript / TypeScript 运行时。 让我们从 Deno 的功能列表快速了解： Deno 基于最新的 JavaScript 语言； Deno 具有覆盖面广泛的标准库； Deno 以 TypeScript 为核心，配以更多独特的方式从而带来了巨大的优势，其中包括一流的 TypeScript 支持（Deno 自动编译 TypeScript 而无需你单独编译）； Deno 大力拥抱 ES 模块标准； Deno 没有包管理器； Deno 具有一流的 await 语法支持； Deno 内置测试工具； Deno 旨在尽可能地与浏览器兼容，例如通过提供内置对象 fetch 和全局 window 对象。 我们将在本手册中展开探索所有上述功能。 在你实战完 Deno 并了解它独特的功能魅力后，Node.js 或许会看起来有些过时。 特别是因为 Node.js 的 API 是基于回调机制的，因为 Node.js 是在 Promise 和 Async / Await 定义在标准之前编写的。Node.js 中无法对此机制进行全新的更改，因为此类更改将产生“毁灭性”的影响。因此，在 Node.js 中我们陷入了回调大量 API 的困境。 Node.js 的确很棒，并在可见的未来将继续成为 JavaScript 世界中事实上的标准。但我认为我们将逐渐看到 Deno 会因其一流的 TypeScript 支持和其内置的、覆盖面广泛的现代标准库而越来越被重视和采用。 由于没有向后兼容性的历史原因，Deno 将可以承担起所有使用现代 Web 技术编写的工程建设。但目前的现实是，我们也无法保证十年之内 Deno 不会发生像 Node.js 同样的事情，并且不会出现一项新技术代替 Deno。 为什么是 Deno？为什么是现在？大约 2 年前，Node.js 的创建者 Ryan Dahl 在 JSConf EU 上首次介绍了 Deno。观看当时的演讲视频会非常有趣。如果你平时在大量接触 Node.js 和 JavaScript，这个视频请不要错过。 每个项目经理都必须下发决定。Ryan 回看 Node.js 中的一些早期设计依然感觉十分遗憾。此外，在 ES6/2016/2017 等持续发展中的标准加持下，如今的 JavaScript 与 2009 年 Node.js 创立时的 JavaScript 已经大不相同。 因此，他开启了一个全新项目，从而创建出服务器端的第二代 JavaScript 运行时。 新生的技术需要大量时间才能成熟，这正是我现在撰写本手册而不是两年前就开始撰写的原因。如今，第一个正式稳定的 Deno v1.0 版本终于指日可待（不出意外的话，v1.0 会在 2020 年 5 月 13 日发布）。 译者注：翻译本手册时 Deno 1.0 已经发布。 1.0 看起来仅仅是个数字，但在社区约定下，意味着直到 Deno 2.0 前 Deno 都不会有太多重大的破坏性改变——这很重要，因为你终于可以安心学习 Deno 当前的稳定版本了。 你应该学习 Deno 吗？这并不那么容易回答。 学习像 Deno 这样全新的知识需要不少的前期技术沉淀。我的建议是：如果你现在才开始在服务器端使用 JavaScript 编程，并且你还不了解 Node.js，更没有任何 TypeScript 应用开发经验——那么请从 Node.js 学起。 毕竟用通俗观点来说，没有人会在如今因为选择学习 Node.js 而被解雇。 但如果你喜欢 TypeScript、也不想让项目中依赖无比庞大的 NPM 软件包、还想要随时随地使用 await 等语法，那么你可能真的需要 Deno。 Deno 将取代 Node.js 吗？不能。Node.js 的生态已经十分庞大和完善，获得了数以万计的优秀技术支持，将能再战数十年。 一流的 TypeScript 支持Deno 基于 Rust 和 TypeScript 这两种今天正在迅速发展的语言编写。 这意味着，即使我们可能选择编写纯 JavaScript 代码来运行在基于 TypeScript 语言编写的 Deno 上，我们也可以获得 TypeScript 的很多好处。 使用 Deno 运行 TypeScript 代码无需任何手动编译——Deno 会自动为你执行此步骤。 你不必非得在 Deno 上编写 TypeScript 代码，但是 Deno 因其核心由 TypeScript 语言编写的如下相关背景是不容忽视的： 首先，越来越多的 JavaScript 程序员开始喜欢上了 TypeScript 语言。 其次，你使用的工具可以方便地推断出许多有关用 TypeScript 语言编写的软件的信息，例如 Deno。 因此，当我们在 VS Code（紧密集成 TypeScript 的编辑器）上的编码环节就能及时地体会到类型检查和高级智能感知（IntelliSense）功能带来的好处。换句话说，编辑器可以以非常有用的方式来帮助我们了解 TypeScript 项目。 与 Node.js 的异同由于 Deno 从某种角度来讲是 Node.js 的替代品，因此直接比较两者的异同对我们的理解会很有帮助。 相似之处： 两者都是基于 V8 引擎开发的； 两者都非常适合在服务器端上编写 JavaScript 应用。 差异之处： Node.js 用 C++ 和 JavaScript 语言编写。Deno 用 Rust 和 TypeScript 语言编写。 Node.js 有一个官方的软件包管理器，称为 NPM。Deno 不会有，而会允许你从 URL 导入任何 ES 模块。 Node.js 使用 CommonJS 模块语法导入软件包。Deno 使用 ES 标准模块导入。 Deno 在其所有 API 和标准库中都使用现代 ECMAScript 功能，而 Node.js 使用基于回调的标准库，并且没有计划对其进行升级。 Deno 通过权限控制提供了一个安全的沙箱环境，程序只能访问由用户设置为可执行标志的文件。Node.js 程序可以直接访问用户足以访问的任何内容。 Deno 长期以来一直在探索将程序编译成单个可执行文件的可能性，从而使得该可执行文件可以在没有外部依赖项（例如 Go）的情况下运行，但这并不是一件容易的事，如果做得到，将会成为更有话语权的游戏规则改变者。 没有包依赖管理器没有像 NPM 一样的程序包管理器并且大量依靠 URL 来承载和导入程序包是有利有弊的。但我真的很喜欢这个特性：它将会非常灵活，我们可以直接创建软件包而无需在 NPM 这样的存储库中发布它们。 虽然还没有官方的消息，但我认为 Deno 下的某种软件包管理器将会出现。 与此同时，Deno 网站为第三方软件包提供代码托管服务（并帮助其通过 URL 分发）：详见 https://deno.land/x/。 安装 Deno就闲聊到这里吧！让我们开始着手安装 Deno。 最简单的方法是使用 Homebrew： 1brew install deno 输出如上命令后，你将可以访问 deno 命令。帮助是deno --help： 译者注：如果 HomeBrew 安装太慢可以尝试输入如下命令手动关闭 HomeBrew 的自动更新检测： export HOMEBREW_NO_AUTO_UPDATE=true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162flavio@mbp~&gt; deno --helpdeno 0.42.0A secure JavaScript and TypeScript runtimeDocs: https://deno.land/std/manual.mdModules: https://deno.land/std/ https://deno.land/x/Bugs: https://github.com/denoland/deno/issuesTo start the REPL, supply no arguments: denoTo execute a script: deno run https://deno.land/std/examples/welcome.ts deno https://deno.land/std/examples/welcome.tsTo evaluate code in the shell: deno eval \"console.log(30933 + 404)\"Run 'deno help run' for 'run'-specific flags.USAGE: deno [OPTIONS] [SUBCOMMAND]OPTIONS: -h, --help Prints help information -L, --log-level &lt;log-level&gt; Set log level [possible values: debug, info] -q, --quiet Suppress diagnostic output By default, subcommands print human-readable diagnostic messages to stderr. If the flag is set, restrict these messages to errors. -V, --version Prints version informationSUBCOMMANDS: bundle Bundle module and dependencies into single file cache Cache the dependencies completions Generate shell completions doc Show documentation for a module eval Eval script fmt Format source files help Prints this message or the help of the given subcommand(s) info Show info about cache or info related to source file install Install script as an executable repl Read Eval Print Loop run Run a program given a filename or url to the module test Run tests types Print runtime TypeScript declarations upgrade Upgrade deno executable to newest versionENVIRONMENT VARIABLES: DENO_DIR Set deno's base directory (defaults to $HOME/.deno) DENO_INSTALL_ROOT Set deno install's output directory (defaults to $HOME/.deno/bin) NO_COLOR Set to disable color HTTP_PROXY Proxy address for HTTP requests (module downloads, fetch) HTTPS_PROXY Same but for HTTPS Deno 命令请注意上节中 deno --help 后 SUBCOMMANDS 中的部分，其中列出了我们在当前版本（0.42.0）中可以运行的所有命令，如下： bundle ：将项目的模块和依赖项捆绑到单个文件中； cache ：缓存依赖项； completions ：generate shell completions； doc ：显示某模块的文档； eval ：运行一段代码，例如 deno eval &quot;console.log(1 + 2) ； fmt ：内置的代码格式化程序（类似于 Go 语言中的 gofmt）； help ：打印某消息或某给定子命令的帮助信息； info ：显示有关缓存的信息或与源文件有关的信息； install ：将脚本安装为可执行文件； repl ：开启 REPL 环境（默认子命令）； run ：运行给定文件名或 URL 的程序； test ：运行测试； types ：打印运行时的 TypeScript 声明； upgrade ：升级 Deno 到最新版本。 你可以运行 deno &lt;subcommand&gt; help 以获取该子命令的特定文档，例如 deno run --help。 如下所示，我们可以直接输入 deno 命令命令来默认启动 REPL（Read-Execute-Print-Loop）环境直接调试功能，这与运行 deno repl 效果是相同的。 一个更常见的直接使用 deno 命令的场景是执行在 TypeScript 文件中写的 Deno 应用程序。 译者注：现在需要使用 deno run 命令而非 deno 命令来执行 TypeScript 文件。 你可以同时运行 TypeScript（.ts）文件或 JavaScript（.js）文件。 如果你不熟悉 TypeScript，请不要担心——Deno 是用 TypeScript 编写的，并且你可以使用纯 JavaScript 编写“客户端”应用程序。 如果你想快速上手的 TypeScript 话，可以阅读我的 TypeScript 教程。 你的第一个 Deno 应用让我们来运行第一个 Deno 应用程序。 Deno 让我感到非常惊奇的特性是：你甚至不必写一行代码，便可以直接运行任何 URL 上的 Deno 应用程序。 此时 Deno 会将 URL 上的程序下载到本地并进行编译，然后运行： 当然，我一般不建议从 Internet 运行无法保障安全性的代码。在这种情况下，我们先运行 Deno 官方网站上提供的 Demo；另外 Deno 还有一个沙箱，可以阻止程序执行你不希望做的事情。稍后再详细介绍。 这个程序很简单，只需要一个console.log()调用： 1console.log(\"Welcome to Deno 🦕\"); 如果使用浏览器打开直接打开 https://deno.land/std/examples/welcome.ts 这个 URL，则会看到以下页面： 奇怪吧？你可能期待着打开 URL 后出现一个纯 TypeScript 文件以供下载，但是我们却看到了一个网页。原因是 Deno 网站的 Web 服务器知道你正在使用浏览器，并为你提供了对用户更加友好的页面。 为了验证这个功能，我们可以使用 wget 命令来测试这个 URL， wget 使用 text/plain 下载文本而不是 text/html： 如果你想再运行这个程序，现在已经被 Deno 缓存了，不需要再下载和编译了。 你可以用 --reload 参数强制重新下载和编译原始源码。 在当前版本（0.42.0）中，deno --run 有许多未在 deno --help 清单中列出的功能。你需要运行 deno run --help 以显示更多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106flavio@mbp~&gt; deno run --helpdeno-runRun a program given a filename or url to the module.By default all programs are run in sandbox without access to disk, network orability to spawn subprocesses. deno run https://deno.land/std/examples/welcome.tsGrant all permissions: deno run -A https://deno.land/std/http/file_server.tsGrant permission to read from disk and listen to network: deno run --allow-read --allow-net https://deno.land/std/http/file_server.tsGrant permission to read whitelisted files from disk: deno run --allow-read=/etc https://deno.land/std/http/file_server.tsUSAGE: deno run [OPTIONS] &lt;SCRIPT_ARG&gt;...OPTIONS: -A, --allow-all Allow all permissions --allow-env Allow environment access --allow-hrtime Allow high resolution time measurement --allow-net=&lt;allow-net&gt; Allow network access --allow-plugin Allow loading plugins --allow-read=&lt;allow-read&gt; Allow file system read access --allow-run Allow running subprocesses --allow-write=&lt;allow-write&gt; Allow file system write access --cached-only Require that remote dependencies are already cached --cert &lt;FILE&gt; Load certificate authority from PEM encoded file -c, --config &lt;FILE&gt; Load tsconfig.json configuration file -h, --help Prints help information --importmap &lt;FILE&gt; UNSTABLE: Load import map file Docs: https://deno.land/std/manual.md#import-maps Specification: https://wicg.github.io/import-maps/ Examples: https://github.com/WICG/import-maps#the-import-map --inspect=&lt;HOST:PORT&gt; activate inspector on host:port (default: 127.0.0.1:9229) --inspect-brk=&lt;HOST:PORT&gt; activate inspector on host:port and break at start of user script --lock &lt;FILE&gt; Check the specified lock file --lock-write Write lock file. Use with --lock. -L, --log-level &lt;log-level&gt; Set log level [possible values: debug, info] --no-remote Do not resolve remote modules -q, --quiet Suppress diagnostic output By default, subcommands print human-readable diagnostic messages to stderr. If the flag is set, restrict these messages to errors. -r, --reload=&lt;CACHE_BLACKLIST&gt; Reload source code cache (recompile TypeScript) --reload Reload everything --reload=https://deno.land/std Reload only standard modules --reload=https://deno.land/std/fs/utils.ts,https://deno.land/std/fmt/colors.ts Reloads specific modules --seed &lt;NUMBER&gt; Seed Math.random() --unstable Enable unstable APIs --v8-flags=&lt;v8-flags&gt; Set V8 command line options. For help: --v8-flags=--helpARGS: &lt;SCRIPT_ARG&gt;... script args Deno 代码实例除了前文我们运行的 Demo 外，Deno 官网还提供了一些其他的例子，可以在这里查看：https://deno.land/std/examples/。 译者注：你可能需要配置代理来更好地访问 DenoLand。 在撰写本手册时，我们可以找到： cat.ts ：打印的内容是作为参数提供的文件列表； catj.ts ：打印的内容是作为参数提供的文件列表； chat/ ：聊天的一种实现； colors.ts ：打印一个彩色版本的 Hello world!； curl.ts ：一个简单的实现，curl 它打印指定为参数的 URL 的内容； echo_server.ts ：TCP 回显服务器； gist.ts ：一个将文件发布到 gist.github.com 的程序； test.ts ：样本测试套件； welcome.ts ：一个简单的 console.log 语句（我们在上面运行的第一个程序）； xeval.ts ：允许你为收到的任何标准输入行运行任何 TypeScript 代码。曾经被设计为 deno xeval 子命令但现在从官方命令中删除。 你的第一个 Deno 应用（深入版）我们来写一些代码吧。 前文执行的 deno run [https://deno.land/std/examples/welcome.ts](https://deno.land/std/examples/welcome.ts) 命令执行的是官网提供的一个 Deno 应用，所以我们没有看到任何关于 Deno 代码具体的样子。 接下来让我们从 Deno 官方网站上列出的默认示例应用开始。 123456import { serve } from \"https://deno.land/std/http/server.ts\";const s = serve({ port: 8000 });console.log(\"http://localhost:8000/\");for await (const req of s) { req.respond({ body: \"Hello World\\n\" });} 这段代码从 http/server 模块中导入服务函数。可见我们不需要先安装这些模块，而且也不会像 Node.js 那样将这些模块大量存储在本地机器上。这也是 Deno 安装速度快的原因之一。 从 [https://deno.land/std/http/server.ts](https://deno.land/std/http/server.ts) 中导入会导入最新版本的模块。你可以使用@VERSION导入特定的版本，如下所示。 1import { serve } from \"https://deno.land/std@v0.42.0/http/server.ts\"; 该 serve 函数在此文件中的定义如下： 12345678910111213141516171819/** * Create a HTTP server * * import { serve } from \"https://deno.land/std/http/server.ts\"; * const body = \"Hello World\\n\"; * const s = serve({ port: 8000 }); * for await (const req of s) { * req.respond({ body }); * } */export function serve(addr: string | HTTPOptions): Server { if (typeof addr === \"string\") { const [hostname, port] = addr.split(\":\"); addr = { hostname, port: Number(port) }; } const listener = listen(addr); return new Server(listener);} 我们接下来实例化一个服务器，调用 server() 函数传递一个带有端口属性的对象。 然后我们运行如下循环来响应来自服务器的每一个请求。 123for await (const req of s) { req.respond({ body: \"Hello World\\n\" });} 请注意，我们在这里使用 await 关键字而不需要将其封装到异步函数中，因为 Deno 在其内部实现了顶层的 await 支持。 让我们在本地运行这个程序。假设你使用的是 VS Code（你可以使用任何你喜欢的编辑器），我建议从 justjavac 开发的 Deno VS Code 扩展入手（当我尝试的时候还有一个同名的扩展，但是已经被淘汰了，可能将来会消失）。 译者注：justjavac 的 Deno VS Code 拓展将被官方收录，以后可以直接使用官方的拓展。 该扩展将为 VS Code 提供几个实用工具和不错的东西来帮助你编写应用程序。 现在在一个文件夹中创建一个 app.ts 文件，然后粘贴上面的代码。 现在用 deno run app.ts 命令运行它。 Deno 会先下载、编译我们导入的那个依赖及其所有需要的依赖项。 这是由于我们导入的 [https://deno.land/std/http/server.ts](https://deno.land/std/http/server.ts) 文件本身就有数个其它依赖： 1234567891011121314import { encode } from \"../encoding/utf8.ts\";import { BufReader, BufWriter } from \"../io/bufio.ts\";import { assert } from \"../testing/asserts.ts\";import { deferred, Deferred, MuxAsyncIterator } from \"../async/mod.ts\";import { bodyReader, chunkedBodyReader, emptyReader, writeResponse, readRequest,} from \"./_io.ts\";import Listener = Deno.Listener;import Conn = Deno.Conn;import Reader = Deno.Reader; 但 Deno 都会帮我们自动导入。 在最后，我们还有一个问题。 这是怎么回事？我们为什么会收到执行权限被拒绝的提示？ 这就涉及到了 Deno 的 Sandbox 问题，我们一起来看看。 Deno 安全沙箱（Sandbox）我之前提到过，Deno 有一个安全沙箱，可以防止程序做一些你不允许的事情。 这意味着什么呢？ Ryan 曾在 Deno 的介绍讲座中提到的一件事是：有时候你想在 Web 浏览器之外运行一个 JavaScript 程序，却不想让它肆意在你的系统中访问任何它想要的东西，比如使用网络与外部世界对话。 为什么我们通常只安装来自可信来源的 Node.js 包？这是因为没有什么可以阻止 Node.js 程序获取你系统上的 SSH 密钥或其他任何东西，并将其发送到服务器上。但是，我们该怎么知道自己或其他人使用的一个项目是否被黑客入侵了？ Deno 的解决方案是试图大量借鉴浏览器实现相同的权限模型——除非你明确允许，否则在浏览器中运行的任何 JavaScript 都不能在你的系统上做不正当的事情。 回到 Deno，如果一个程序想要像前面的例子一样访问网络，那么我们需要给它权限。 我们可以通过在运行命令时传递一个标志来实现，本例中是 --allow-net。 1deno run --allow-net app.ts 该应用程序现在监听在 8000 端口上运行着 HTTP 服务器： 其他标志允许 Deno 解锁其他功能，如下所示： --allow-env ：允许访问环境变量； --allow-hrtime ：允许高分辨率时间测量； --allow-net=&lt;allow-net&gt; ：允许网络访问； --allow-plugin ：允许加载插件； --allow-read=&lt;allow-read&gt; ：允许文件系统读取权限； --allow-run ：允许运行子进程； --allow-write=&lt;allow-write&gt; ：允许文件系统写入访问； --allow-all ：允许所有权限(与-A相同)。 其中，net、read 和 write 的权限可以是细化的。例如，你可以使用 --allow-read=/dev，允许从特定文件夹中读取。 格式化代码Go 语言编译器自带的 gofmt 命令是我非常喜欢 Go 语言特性之一。所有的 Go 代码的格式看起来都是一样的。每位 Go 程序员都在使用 gofmt。 JavaScript 程序员都习惯于运行 Prettier 工具，而 deno fmt 实际上直接内置相关库到底层上运行。 假设你有一个格式化问题严重的文件如下图所示。 你运行 deno fmt app.ts，它就会执行正确的代码格式化，包括自动加上缺失的分号。 标准库尽管 Deno 还很年轻，但它的标准库仍然很庞大。这包括： archive ：tar 文件归档的实用程序 async ：异步工具 bytes ：帮助器来操作字节切片 datetime ：日期 / 时间解析 encoding ：各种格式的编码/解码 flags ：解析命令行标志 fmt ：格式化和打印 fs ：文件系统 API hash ：加密库 http ：HTTP 服务器 io ：I/O 库 log ：日志实用程序 mime ：支持多类型数据 node ：Node.js 兼容层 path ：路径操纵 ws ：WebSockets 另一个 Deno 示例我们再来看看另一个 Deno APP 的例子，以如下 cat.ts 为例。 123456const filenames = Deno.args;for (const filename of filenames) { const file = await Deno.open(filename); await Deno.copy(file, Deno.stdout); file.close();} 这里把 Deno.args 的值分配给了 filenames 变量，Deno.args 是一个包含所有发送到命令中的参数的变量。 我们对这些参数进行迭代：对每一个参数，我们使用 Deno.open() 打开文件，并使用 Deno.copy() 将文件的内容打印到 Deno.stdout 中，最后我们关闭该文件。 如果你使用如下命令： 1deno run https://deno.land/std/examples/cat.ts 程序被下载编译后，由于我们没有指定任何参数，所以没有发生任何事情。 现在试试这个： 1deno run https://deno.land/std/examples/cat.ts app.ts 假设你在同一个文件夹里有之前项目中的 app.ts。 你会得到如下权限错误。 这是因为 Deno 默认情况下不允许访问文件系统。需要使用 --allow-read=./ 命令授予对当前文件夹的访问权限： 1deno run --allow-read=./ https://deno.land/std/examples/cat.ts app.ts Deno 是否有 Express/Hapi/Koa/*当然有。可以看看下方这些库。 deno-drash deno-express oak pogo servest 示例：使用 Oak 构建 REST-API我想在这里做一个简单的 Demo 实战，介绍一下如何使用 Oak 框架构建REST API。Oak 很有意思，因为它的灵感来自于 Koa，一个流行的 Node.js 中间件。正因为如此，如果你以前用过 Koa 的话，会很快熟悉 Oak。 我们要构建的 API 示例也非常简单。 我们的服务器将在内存中存储一个带有名字和年龄的旺柴的列表。 我们的需求是： 添加旺柴； 列出旺柴； 获取有关特定旺柴的详细信息； 从名单上删除一只旺柴； 更新旺柴的年龄。 我们将使用 TypeScript 进行此操作，但是没有什么可以阻止你使用 JavaScript 编写 API——你只需要删除下方 TypeScript 文件中所有有关类型描述的代码并将文件名后缀改为 .js。 创建一个 app.ts 文件。 让我们开始从 Oak 导入 Application 和 Router 对象： 1import { Application, Router } from \"https://deno.land/x/oak/mod.ts\"; 然后我们得到环境变量 PORT 和 HOST: 123const env = Deno.env.toObject();const PORT = env.PORT || 4000;const HOST = env.HOST || \"127.0.0.1\"; 默认情况下，我们的应用程序将在 localhost：4000 上运行。 现在，我们创建 Oak 应用程序并启动它： 12345678910const router = new Router();const app = new Application();app.use(router.routes());app.use(router.allowedMethods());console.log(`Listening on port ${PORT}...`);await app.listen(`${HOST}:${PORT}`); 现在，应用程序应该可以正常编译了。 1deno run --allow-env --allow-net app.ts 然后 Deno 将下载依赖项： 这时程序监听在 4000 端口上。 下次运行该命令时，Deno 会跳过安装部分，因为这些包已经被缓存了。 在文件的顶部，让我们定义一个旺柴的接口，然后我们声明一个初始的 Dogs 数组 Dog 对象。 123456789101112131415interface Dog { name: string; age: number;}let dogs: Array&lt;Dog&gt; = [ { name: \"Roger\", age: 8, }, { name: \"Syd\", age: 7, },]; 现在，让我们来实现具体 API。 我们已经准备好了一切。在你创建了路由器之后，让我们添加一些函数，这些函数将在任何时候触发这些路由中的一个端点时被调用。 12345678const router = new Router();router .get(\"/dogs\", getDogs) .get(\"/dogs/:name\", getDog) .post(\"/dogs\", addDog) .put(\"/dogs/:name\", updateDog) .delete(\"/dogs/:name\", removeDog); 看到了吗？我们的 API 定义是： GET /dogs GET /dogs/:name POST /dogs PUT /dogs/:name DELETE /dogs/:name 让我们开始一一实现。 从开始 GET /dogs，它将返回所有旺柴的列表： 123export const getDogs = ({ response }: { response: any }) =&gt; { response.body = dogs;}; 接下来，我们就来看看如何通过名字来检索旺柴。 12345678910111213141516171819export const getDog = ({ params, response,}: { params: { name: string; }; response: any;}) =&gt; { const dog = dogs.filter((dog) =&gt; dog.name === params.name); if (dog.length) { response.status = 200; response.body = dog[0]; return; } response.status = 400; response.body = { msg: `Cannot find dog ${params.name}` };}; 这是我们添加一个新的旺柴的方法： 1234567891011121314export const addDog = async ({ request, response,}: { request: any; response: any;}) =&gt; { const body = await request.body(); const dog: Dog = body.value; dogs.push(dog); response.body = { msg: \"OK\" }; response.status = 200;}; 注意，我现在使用 const body = await request.body() 来获取正文的内容，因为 name 和 age 值是以 JSON 的形式传递的。 这是我们更新旺柴的年龄的方法： 12345678910111213141516171819202122232425export const updateDog = async ({ params, request, response,}: { params: { name: string; }; request: any; response: any;}) =&gt; { const temp = dogs.filter((existingDog) =&gt; existingDog.name === params.name); const body = await request.body(); const { age }: { age: number } = body.value; if (temp.length) { temp[0].age = age; response.status = 200; response.body = { msg: \"OK\" }; return; } response.status = 400; response.body = { msg: `Cannot find dog ${params.name}` };}; 这是我们如何从列表中删除旺柴的方法： 123456789101112131415161718192021export const removeDog = ({ params, response,}: { params: { name: string; }; response: any;}) =&gt; { const lengthBefore = dogs.length; dogs = dogs.filter((dog) =&gt; dog.name !== params.name); if (dogs.length === lengthBefore) { response.status = 400; response.body = { msg: `Cannot find dog ${params.name}` }; return; } response.body = { msg: \"OK\" }; response.status = 200;}; 这是完整的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import { Application, Router } from \"https://deno.land/x/oak/mod.ts\";const env = Deno.env.toObject();const PORT = env.PORT || 4000;const HOST = env.HOST || \"127.0.0.1\";interface Dog { name: string; age: number;}let dogs: Array&lt;Dog&gt; = [ { name: \"Roger\", age: 8, }, { name: \"Syd\", age: 7, },];export const getDogs = ({ response }: { response: any }) =&gt; { response.body = dogs;};export const getDog = ({ params, response,}: { params: { name: string; }; response: any;}) =&gt; { const dog = dogs.filter((dog) =&gt; dog.name === params.name); if (dog.length) { response.status = 200; response.body = dog[0]; return; } response.status = 400; response.body = { msg: `Cannot find dog ${params.name}` };};export const addDog = async ({ request, response,}: { request: any; response: any;}) =&gt; { const body = await request.body(); const { name, age }: { name: string; age: number } = body.value; dogs.push({ name: name, age: age, }); response.body = { msg: \"OK\" }; response.status = 200;};export const updateDog = async ({ params, request, response,}: { params: { name: string; }; request: any; response: any;}) =&gt; { const temp = dogs.filter((existingDog) =&gt; existingDog.name === params.name); const body = await request.body(); const { age }: { age: number } = body.value; if (temp.length) { temp[0].age = age; response.status = 200; response.body = { msg: \"OK\" }; return; } response.status = 400; response.body = { msg: `Cannot find dog ${params.name}` };};export const removeDog = ({ params, response,}: { params: { name: string; }; response: any;}) =&gt; { const lengthBefore = dogs.length; dogs = dogs.filter((dog) =&gt; dog.name !== params.name); if (dogs.length === lengthBefore) { response.status = 400; response.body = { msg: `Cannot find dog ${params.name}` }; return; } response.body = { msg: \"OK\" }; response.status = 200;};const router = new Router();router .get(\"/dogs\", getDogs) .get(\"/dogs/:name\", getDog) .post(\"/dogs\", addDog) .put(\"/dogs/:name\", updateDog) .delete(\"/dogs/:name\", removeDog);const app = new Application();app.use(router.routes());app.use(router.allowedMethods());console.log(`Listening on port ${PORT}...`);await app.listen(`${HOST}:${PORT}`); 更多内容Deno 官方网站为 https://deno.land。 API 文档位于 https://doc.deno.land 和 https://deno.land/typedoc/index.html 中。 一份 Awesome Deno 资源清单 https://github.com/denolib/awesome-deno。 译者注：中文的 Awesome Deno 清单由译者持续维护中，可以访问这里：Awesome Deno 资源全图谱 花絮 Deno 提供了一个内置的 fetch 实现，该实现与浏览器中可用的匹配。 Deno 正在进行与 Node.js stdlib 的兼容层 结语我希望你喜欢这个 Deno 入门手册！ 别忘了，你可以在此处获取此 Deno 手册的 PDF / ePub / Mobi 版本。","link":"/blog/2020/05/18/00A-deno-handbook-typescript/"},{"title":"Awesome Deno 中文资源全图谱","text":"《Deno 钻研之术》系列于 Deno v1 正式发售之日全新推出，每周不定期更新在 Github 中（https://github.com/hylerrix/deno-tutorial）。让我们一起循序渐进学 Deno，先易后难补 Node，面向未来开发属于自己的 Deno Web App。欢迎订阅，欢迎交流。 一个全新的技术会有怎样的生态？在对 Deno 的好奇和梳理过程中，基于已有的 Awesome Deno 英文列表全新出发，一个专注于中文技术圈的 Deno 资源列表呼之欲出。 为什么是 Awesome？Github 集市上广受欢迎的仓库有这么几大类： 语言类：如 Go、Rust、TypeScript 等，提供高级语言曾经的支持； 基础设施类：如 Linux、Docker 以及云设施等，用来运行、构建更多的顶层应用； 框架/库/运行时类：如 Deno、React、Tensorflow 等，搭建业务的基石； 业务类：如 freeCodeCamp、近期的疫情网站等，将整个项目业务源码开放给社区维护； 插件类：给各大浏览器、编辑器等环境提供拓展功能； Demo 类：对某项技术进行专项训练和分享； …… 此外，还有一类上面没有提到的，便是文档类。这包括开放的电子书、开放的博客以及开放的清单——名字带有 Awesome 的清单项目，就成了一套约定俗称的独特风景线。Github 上搜索 Awesome 关键字，可以看到围绕各个知名技术点的仓库中都有若干个获得数以万计的 Star 收藏。这一点连谷歌搜索引擎都做不到。 开源，不仅仅是知识内容的公开，更是协作一切的基石。 该怎样写好 Awesome 清单的 README.md？ 由于 Awesome 项目大多只需要从仓库中的 README.md 展示所有内容，所以写出一个良好的 README.md 便是十分重要的。这包括： 友好的介绍文字：开门见山； 设计良好的目录：能从目录快速了解和索引这一切； 酷炫的 Logo：紧跟所围绕的技术本身 Logo 走； 可选的更新日志和路线图：让用户知道未来的方向； 参与贡献的方式与开源协议：鼓励更多人参与贡献； 一些独特性：标新立异，难以忘记。 没有技术含量的 Awesome 清单整理太无聊？ 的确，单纯的梳理也需要花费不少的时间，累加起来都能玩好几局不错的游戏。对于自身的技术成长来说，也不会有直观的改进。但最重要的好处是，维护一份 Awesome 清单，可以让自己亲自参与创造，有更主动的机会去比别人更敏锐地观察生态圈的发展历程甚至发展方向。 该不该建立属于自己的 Awesome 清单？ 如果你的技术学习时间较为充分，花一小部分时间来在社区维护一份 Awesome 清单是十分有趣的，也可以了解很多生态故事，结识很多好友。切记需要考虑的是：社区中是不是已经有相关的 Awesome 资源，并且已经初步“占领”市场了？毕竟没有人会喜欢给一大堆相差无几的清单点 Star。如果像本文这份清单一样，社区中已经有一份英文清单，再自己维护一份专注中文版的清单一起成长，也不错。 Awesome 的未来是什么？ 文档就够了，我们可以翻阅到想要的一切。然而从程序员的角度来看这份清单，是不是能抽离出很多共同点？都是层级的标题下放置若干个链接、每个链接可能是文章、仓库地址、网站网址、视频地址等，最后再配上通用的介绍文字/贡献指南和开源协议…我有一个想法，就差一个程序员了。 急需你的贡献。 纯个人的梳理局限性很大，也很繁琐，快在社区中选个感兴趣的 Awesome 清单贡献开源吧！比如，这个 Awesome Deno CN？ 正式开始吧。 注：本文截止统计于 2020-05-22，更多内容随时更新在 Github 上的 Awesome Deno CN 中。 Deno 中文资源全图谱 · v1.0.0 目录 为什么有这个项目？ 独特之处 更新日志 贡献者 前言：从 Node.js 到 Deno.js 技术文档 官方文档 中文社区文档 基础设施 DenoLand 核心库 Deno 周边社区库 第三方库 在线沙箱 Demo 技术教程 演讲稿（中文） 演讲稿（英文） 单篇文章（中文） 单篇文章（英文） 翻译文章（中文） 系列文章（中文） 系列文章（英文） 技术专栏（中文） 技术专栏（英文） 在线视频（中文） 在线视频（英文） 电子资源 技术社区 社区列表（全网） 讨论热帖（中文） 讨论热帖（英文） Github 开源组织 谁在用 Deno？ 其它订阅 新闻媒体（英文） 社交媒体（英文） 开源协议 以下资源 🌟 代表品质推荐，⚠️ 代表注意事项。由于资源分类的多样性考虑，部分章节内容可能会有所重复。 独特之处 长期提供更新，收集越来越多高质量的 Deno 资源，愿我们与 Deno 一起成长。 随着 Deno 主版本进行版本归档更新。 配套独家《Deno 钻研之术》电子书并随着本项目一起成长。 及时跟进 @denolib/awesome-deno 仓库。 及时跟进 @olivewind/awesome-deno 仓库。 开发更好看的 UI 页面来展示这个资源列表。 更新日志 2020-04-14 初始化本项目，填充独特的中文版内容。 2020-04-14 跟进最新的（180+ Star） @olivewind/awesome-deno 仓库内容。 2020-05-13 新增《Deno 钻研之术》项目，将本项目作为前者的配套项目。 2020-05-14 同步最新的 @denolib/awesome-deno 仓库内容。 2020-05-17 跟进中文化后大改版的（200+ Star） @olivewind/awesome-deno-cn 仓库内容。 2020-05-22 全网搜索 Deno 中英文资源并入库，发布 v1.0 版本并收录在《Deno 钻研之术》第二篇中。 前言：从 Node.js 到 Deno.js 《Node.js 的设计缺陷》：官方 PDF 演讲稿。 《Design Mistakes in Node》Node 之父 Ryan Dahl 演讲 PPT 中文版 (2018 JS Conf Berlin)：发布于 2018-06-03。 技术文档官方文档 包括中文社区的文档。 deno.land：🌟，Deno 官网。 Deno API 类型手册： doc.deno.land：自动化 Deno 文档生成器。 Deno Registry：Deno 第三方库汇总。 中文社区文档 @denodev/typedoc：🌟，Deno API 简体中文版。 基础设施DenoLand 核心库 更多的官方模块可以在 deno_std 上找到，目前版本 0.52.0。 deno/std/archive。 deno/std/async。 deno/std/bytes。 deno/std/datetime。 deno/std/encoding。 deno/std/examples。 deno/std/flags。 deno/std/fmt。 deno/std/fs。 deno/std/hash。 deno/std/http。 deno/std/io。 deno/std/log。 deno/std/mime。 deno/std/node。 deno/std/path。 deno/std/permissions。 deno/std/signal。 deno/std/testing。 deno/std/textproto。 deno/std/uuid。 deno/std/ws。 Deno 周边社区库 重点将第三方库中，Github 组织带有 Deno 关键字的库专注整理这里。 @denolib/ms：轻松地将各种时间格式转换为毫秒。 @denolib/qs：具有嵌套支持的 querystring 解析器。 @denolib/camelcase：将破折号/点号/下划线/空格分隔的字符串转换为驼峰式；示例：foo-bar→fooBar。 @denolib/camelcase：将破折号/点号/下划线/空格分隔的字符串转换为camelCase：foo-bar→fooBar。 @denolib/marked：Markdown -&gt; HTML 转换器。 @denolib/ms：轻松地将各种时间格式转换为毫秒。 @denopkg/denopkg：在 Deno 项目中使用 GitHub 上的代码的更简单方法。。 @denopkg/denopkg.com：在 Deno 项目中直接使用来自 GitHub 代码的简单方法。 @denoserverless/http-libs：HTTP 模块和类型。 @denoserverless/jwt：auth0/jsonwebtoken 的端口。 @denoserverless/type-fest：基本 TypeScript 类型的集合（sindresorhus 端口/type-fest） 第三方库 更多内容可以看 Deno 官网上的第三方库列表。可以将你的存储库提交到 deno.land/x 中。 如果你有兴趣帮忙按字母排列下方的列表的话，欢迎 PR！ @allain/expect：在 Deno 中编写 Jest 的助手。 @alosaur/alosaur：具有许多装饰器的 Deno Web框架。 @ameerthehacker/cli-spinner：在执行长任务时在终端中显示微调框。 @ameerthehacker/deno-vscode：利用此扩展利用 VS Code 中内置的 typedef 和 intellisense。 @axetroy/dvm：没有运行时相关性的 Deno 版本管理器。 @BentoumiTech/denox：类似于 package.json 脚本，但在 Deno 上具有权限支持。 @bokuweb/deno-pretty-assert：色彩鲜艳的 deno assert 库。 @bokuweb/deno-pretty-assert：一个 Deno 下的 assertEqual 库。 @bokuweb/wu-diff-js：一个差异库，使用 wu（O（NP））算法计算两个切片之间的差异。 @BoltDoggy/dpm：Deno 软件包管理器，为 Deno 安装全局命令，比如 Denoget。—— DVM。 @BoltDoggy/dcc：Deno 清空缓存，在下次运行时重新加载 dep。 @buildondata/postgres：PostgreSQL 数据库驱动程序。 @cacjs/cac：用于构建命令行应用程序的简单但功能强大的框架。 @cardosomarcos/deno-dotenv：从.env加载deno项目的环境变量。 @dontlaugh/packer-provisioner-deno：一个 Packer 插件，可轻松使用 Deno 脚本构建虚拟机映像。 @eliassjogreen/denon：像 Nodemon 的 Deno 库。 @ekaragodin/clone：一个方便克隆的简单实用程序。 @eliassjogreen/deno_tokenizer：Deno 的简单标记器。 @eliassjogreen/denon../watcher.ts：具有等待生成器的文件监视程序。 @eliassjogreen/webview：Webview 的 Deno 绑定，这是一个用于创建基于 Web 的桌面 GUI 的小型库。 @garronej/evt：EventEmitter 的安全替代品。 @garronej/denoify：对于希望支持 Deno 但不想编写和维护端口的 NPM 模块作者。 @hashrock/deno-fnparse：一个非常简单的 JavaScript 解析器、组合器。 @hashrock/deno-opn：一个可以打开网站、(可执行)文件之类资源的跨平台工具。 @hashrock/deno-fnparse/…/csv：一个简单的 CSV 解析器。 @hashrock/deno-fnparse：一个非常简单的 JavaScript 解析器组合器。 @hashrock/deno-opn：打开网站，文件，可执行文件之类的东西，跨平台。 @hayd/deno-udd：更新面依赖：将导入语句更新为最新发布的版本。 @halvardssm/deno-nessie：为 PostgreSQL、MySQL 和 SQLite 创建，迁移和回滚迁移。 @hayd/deno-docker：数个 Docker 镜像。 @hayd/deno-using：带有 Deno 语句的 Python 样式。 @hayd/deno-globrex：globrex 的端口为 deno，globex 的端口为正则表达式。 @jinjor/watch：文件观察器（热更新）。 @justjavac/vscode-deno：🌟，VS Code 扩展，使用 typescript-deno-plugin 提供 Deno 支持。 @justjavac/dvm：Deno 版本管理器：管理多个活动的 Deno 版本。 @justjavac/typescript-deno-plugin：Deno 语言服务插件，在编辑器中的 TypeScript 文件中提供智能感知。 @justjavac/vscode-deno：VS Code 扩展，使用 typescript-deno-plugin 对 Deno 提供支持。 @jinjor/elm-live-reload：一个用 Deno 编写的 Elm Live Reloader。 @jcardama/deno-slugify：Deno 的字符串节流器。 @jinjor/deno-playground/…/expressive：一个类似于 Express 的 Deno Web 框架。 @jinjor/deno-playground/…/watch：一个文件监听程序。 @jinjor/deno-playground/…/elm-live-reload：用 Deno 编写的 Elm Live Reloader。 @jinjor/deno-task-runner：像 NPM 脚本一样编写任务。 @keroxp/deno-redis：一个由 Deno 实现的实验性的 Redis 客户端。 @keroxp/deno-ws：一个 Websocket 服务器的实验性实现。 @kitsonk/oak：一个用于 Deno 网络服务器的中间件框架。 @keroxp/servest：渐进式HTTP服务器/路由器。 @keroxp/deno-ws：Websocket 服务器的实验性实现。 @keroxp/deno-redis：Redis Client for Deno 的实验实现。 @lucascaro/denoversion：Deno 的 SemVer + Git 版本管理。 @lucascaro/deno-uuid：Deno 的 UUID 模块。 @luvies/lazy：类似于 linq 的惰性求值迭代模块。 @muhibbudins/deno-yaml：一个使用 Deno 的简单 Yaml 解析器。 @MarkTiedemann/deno.mk：用于安装和运行 Deno 的跨平台 Makefile。 @maxmcd/deno-docker：一个 Docker 镜像。 @Maxim-Mazurok/sax-ts：从 sax-js 移植的SAX风格的XML解析器。 @manyuanrong/sql-builder：SQL 查询生成器。 @manyuanrong/dso：一个基于 MySQL 的简单 ORM 库。 @manyuanrong/deno-smtp：SMTP 的 SMTP 邮件发件人。 @manyuanrong/deno-mysql：MySQL 数据库驱动程序。 @manyuanrong/deno_mongo：MongoDB 数据库驱动程序。 @manyuanrong/deno-plugin-prepare：一个用于管理 Dedeno Native 插件依赖关系的库。 @manyuanrong/deno-checksum：SHA1/MD5 算法。 @manyuanrong/deno-deamon：使Deno程序在后台运行。 @manyuanrong/bytes_formater：格式化字节（Uint8Array，ArrayBufferView …）输出，在调试 IO 功能时很有用。 @motss/deno_mod/…/normalize_diacritics：删除字符串中的重音符号/变音符号。 @nekobato/deno-xml-parser：一个从 segmentio/xml-parser 移植的 Deno XML 解析器。 @npmjs.com/deno_ls_plugin：一个 TypeScript 插件，它将允许 Deno 之外的 TypeScript 以类似于在 Deno 内部进行解析的方式来解析模块。 @nekobato/deno-xml-parser：从 segmentio/xml-parser 移植来的 Deno XML 解析器。 @NMathar/deno-express：Node Express已移植到Deno。 @OnikurYH/deno-prettystring：格式化，修剪和删除字符串中字符之间的多余空白。 @oakserver/oak：用于 Deno 网络服务器的中间件框架。 @pietvanzoen/deno-dotenv：Dotenv 处理 deno。 @pikapkg/builders/…/pika deno plugin。 @partheseas/gardens：一个无处不在的 JavaScript 记录实用程序。 @syumai/dejs：一个用于 Deno 的 ejs 模板引擎。 @syumai/dinatra：🌟，一个类似于 Sinatra 的轻量级 Deno Web 应用程序框架。 @syumai/dejs：edeno 的 ejs 模板引擎。 @sholladay/pogo：一个 Deno 服务端框架。 @syumai/denoget：denoget 安装可执行的 deno 脚本。 @syumai/deno-libs/…/denoget：安装可执行的 Deno 脚本。 @syumai/deno-libs/…/denoinit：为 Deno 项目生成有用的文件。 @siokas/denomander：Deno 命令行界面的灵感来自 commander.js。 @timonson/djwt：根据 JWT 和 JWS 规范在 Deno 上创建 JSON Web 令牌（JWT）。 @timonson/gentleRpc：用于 Deno 和浏览器的 JSON-RPC 2.0 TypeScript 库。 @zhmushan/abc：一个不错的 Deno Web 框架。 @zekth/deno_case_style：不同大小写样式的字符串验证器和格式化程序，例如 camelCase 等。 @zekth/deno_random_interval：帮助器生成随机间隔。 @zekth/deno_tiny_templates：Deno 的模板渲染器。 @zhmushan/dev_server：让 TypeScript 文件直接在 script 标签中使用。 底层生态 Deno 本身依赖的技术的清单库 @dzharii/awesome-typeScript。 @semlinker/awesome-typeScript。 @rust-unofficial/awesome-rust。 @sindresorhus/awesome-nodejs。 @avelino/awesome-go。 @jobbole/awesome-go-cn：中文版。 在线沙箱 deno-play.app：（⚠ 证书问题）。 deno.town：在线执行 Deno 代码。 技术教程演讲稿（中文） …逐步添加中，欢迎 Star &amp; Fork &amp; PR。 演讲稿（英文） Ryan Dahl - 我为 Node.js 感到遗憾的 10 件事 | JSConf EU 2018 演讲稿 Ryan Dahl - Deno, 新的服务器端运行时 | JSDC 2018#A01 演讲稿 Ryan Dahl - Deno, 一种新的 JavaScript 方法 | JS Fest 2019 Spring 演讲稿 Rafał Pocztarski — 从 Node.js 到 Deno -使用 V8 和 Rust 构建的 JavaScript / TypeScript 运行时[EN] 演讲稿 Ryan Dahl: JavaScript 和 TypeScript 的安全运行时 | js.la April 2019 演讲稿 Ryan Dahl: Deno, 一种新的 JavaScript 方法 | HolyJS 2019 Piter 演讲稿 Rafał Pocztarski - 什么是 Deno？ 2020年代用于现代 JavaScript 和 TypeScript 后端的新运行时 | Deno Warsaw 演讲稿 Michał Sabiniarz - 如何为 Deno 做贡献 | Deno Warsaw 演讲稿 Bartek Iwańczuk - Deno 内部是如何构建现代运行时 | Deno Warsaw 演讲稿 Ryan Dahl &amp; Kitson Kelly: Deno 是一种新的 JavaScript 方法 | TSConf 2019 单篇文章（中文） 专注于收集高质量的博客文章，更多内容可以在谷歌/百度上搜索。目前 Deno 文章不多，尽可能多的诺列不设内容质量限制。 听说要干掉node.js？用Deno实现价值上亿的AI核心算法试一下：发布于 2020-05-14。 了不起的 Deno 入门教程，发布于 2020-05-14。 Deno 运行时入门教程：Node.js 的替代品：🌟，发布于 2020-01-26。 学得动的 Deno：发布于 2018-10-19。 Deno 并不是下一代 Node.js：🌟，发布于 2018-06-04。 让我们一起来学习别人学不动的 Deno：发布于 2018-06-03。 快速了解 deno 目前的 API：发布于 2018-06-03。 玩 Deno 遇到问题的解决方案：发布于 2018-06-02。 我不看好 Deno：发布于 2020-05-10。 单篇文章（英文） First thoughts about Deno：发布于 2020-05-20。 Is Deno the new Node?：发布于 2020-05-20。 Deno vs. Node.js — Here are the most Important Differences：发布于 2020-05-18。 From Node to Deno：发布于 2020-05-17。 Why I Believe Deno is a Step in the Wrong Direction for JavaScript Runtime Environments：发布于 2020-05-14。 The Deno Handbook: A TypeScript Runtime Tutorial with Code Examples：发布于 2020-05-12。 Learn Deno: Chat app：发布于 2020-05-10。 Deno 1.0: What you need to know：发布于 2020-05-06。 Forget NodeJS! Build native TypeScript applications with Deno 🦖：发布于 2020-02-18。 What’s Deno, and how is it different from Node.js?：发布于 2019-07-09。 What is Deno? A ‘better’ Node.js：发布于 2020-02-28。 Ryan Dahl’s Node.js regrets lead to Deno：发布于 2018-06-21。 翻译文章（中文） 这里专门抽来出来中文文章中，是翻译自其它语言（如英语）的文章。 Deno 1.0 即将发布，你需要知道的都在这里了：原文发布于 2020-05-06 日。 系列文章（中文） 目前包括可能会写成电子书的资源。 Deno 进阶开发笔记：不定时更新。 Deno 手册。 系列文章（英文） V8 Docs for Deno：面向 Deno 的 V8 文档。 A Guide to Deno Core (Design &amp; For Contributors)：(⚠ 内容过期），发布于 2019 年。 Deno 源码贡献指南（英文版）:托管于 Gitbook 上。 技术专栏（中文） Deno 开发者社区：知乎专栏，@justjavac 主导。 Deno 世界：知乎专栏，@嘤嘤 主导。 技术专栏（英文） …逐步添加中，欢迎 Star &amp; Fork &amp; PR。 在线视频（中文） Bilibilii | 【中英双语】Node 之父 - Deno，一个新的 JS 运行时。 Deno 1.0 新特性了解一下。 在线视频（英文） Deno in 100 Seconds。 电子资源 专注收集公开免费的 PDF、PNG 以及电子书等资源，放置在本项目的 resources 文件夹下。 《Node.js 的设计缺陷（英文版）》。 《Node.js 的设计缺陷（中文版）》。 技术社区社区列表（全网） Deno Discord：🌟，Discord 上的 Deno 官方聊天室，有中文社区。 deno.dev：🌟，开发中，@justjavac 主导。 deno.js.cn：🌟，Deno 中文社区，@justjavac 主导。 denocn.org：🌟，Deno 中文社区，@manyuanrong 主导。 yydeno：YY 大前端团队 Deno 仓库。 讨论热帖（中文） Deno 会在短期内取代 Node 吗？：发布于 2020-05-22。 @v2ex/Deno 1.0：发布于 2020-05-13。 @v2ex/看了 Deno，感觉 TS 前景不可估量啊：发布于 2020-03-08。 讨论热帖（英文） Reddit 社区 | Deno。 Github 开源组织 重点收集专注于使用 &amp; 回馈 Deno 生态圈的 Github 组织。暂不考虑可能有内容会与“技术社区”栏目重叠的问题。 Deno Land：Deno 官方 Github 组织。 Deno Dev：Deno 第三方组织之一，@justjavac 主导。 Deno Lib：Deno 第三方组织。 谁在用 Deno？ 重点收集已经部署在生产环境的应用，欢迎推荐你的案例，逐步完善中。 …逐步添加中，欢迎 Star &amp; Fork &amp; PR。 其它订阅新闻媒体（英文） Deno 新闻推送 社交媒体（英文） twitter@deno_land：Deno Land 官方推特。 订阅 &amp; 待续本文编号 002，属于《Deno 钻研之术》的生态篇，未来计划逐步展开添加的章节并填充更多的文章，如： 基础篇：循序渐进学 Deno 基础知识； 标准库篇：深入标准库的内部世界； CLI 篇：探索 CLI 命令行的知识； Web 篇：打造 Web 开发基石； Node 篇：先易后难补 Node 知识，探索与 Deno 的异与同； Rust 篇：探索 Deno 底层有关 Rust 的更多知识； 前端篇：探索 Deno Web 前端应用开发的方式； 后端篇：探索 Deno Web 后端应用开发的方式； 架构篇：深入到 Deno 底层读 V8，学架构； 生态篇：介绍 Deno 生态的相关内容； 翻译篇：【单独编号】翻译优质的、授权的英文一手博文。 欢迎订阅，一起成长，敬请 Star, Watch &amp; Issue 开源仓库《Deno 钻研之术》！。 https://github.com/hylerrix/deno-tutorial/ 题外话：截止今天，短短的 9 天仓库涨到人生第一个 108 Star，我还在繁忙的公司任务外更新的这么慢，有点慌~。那就争取每周 2+ 篇吧。🤡","link":"/blog/2020/05/22/00B-awesome-deno-cn/"},{"title":"Deno + WebSockets 打造聊天室应用","text":"原文地址：Learn Deno: Chat app 原文作者：Aral Roca 原文发布时间：2020-05-10 译者：hylerrix 备注：本文已获原作者授权，同时本文会收录在《Deno 钻研之术》的翻译篇中。 Node.js 最初由 Ryan Dahl 于 2009 年基于 C++ 语言创建。到了 2012 年，Ryan 觉得自己或多或少地已经实现了当年的目标便离开了 Node.js 项目。 如今他的目标已大不相同：在意识到无法轻易在 Node.js 中修复某些当时的错误设计后，他决定创建一个全新的 JavaScript（也包括如今流行的 TypeScript） 运行时——基于 Rust 语言实现的 Deno。 Deno 1.0.0 版本将于 2020 年 05 月 13 日正式发布。 我们将在本文中探索 Deno 是如何工作的、Deno 和 Node.js 有什么区别并实现一个简单的聊天室程序。 本文的目录如下： 安装 Deno 简单的 “Hello World” 实战 本地监听 index.html 文件 引入 WebSockets 第三方库与 Dep.ts 约定 编写测试代码 浏览器调试 总结 本文的代码 参考文献 安装 Deno有各种各样安装 Deno 的方法：使用 curl、iwr、Homebrew、Chocolatey…，可以参阅此处查看如何安装。 Deno 没有外部依赖性，是个单独的二进制可执行文件。 本文将采用 Homebrew 来安装： 12345➜ ~ brew install deno➜ ~ deno --versiondeno 1.0.0-rc1v8 8.2.308typescript 3.8.3 我们可以看到，Deno 上没有类似 npm 的包管理器——Npm 在 Node 生态系统中变得至关重要，它是模块的集中（也可以私有化控制）存储库。 Deno 正在改变这一现状。稍后我们将看到如何在无需 package.json 和 node_modules 文件的情况下安装并执行软件包。 我们可以使用 deno upgrade 命令来将 Deno 升级为最新的版本。 我推荐使用 deno help 来了解 Deno 上可以使用的各种命令： 译者注：为方便阅读，下方打印的结果部分内容也进行翻译。 12345678910111213141516171819202122232425262728293031使用方式: deno [OPTIONS] [SUBCOMMAND]OPTIONS（选项）: -h, --help 打印帮助信息 -L, --log-level &lt;log-level&gt; 设置日志的等级【可选值包括 debug、info】 -q, --quiet 禁止输出诊断信息 -V, --version 打印版本信息SUBCOMMAND（子命令）: bundle 将项目的模块和依赖项捆绑到单个文件中 cache 缓存依赖项 completions 生成 Shell 补全信息 doc 显示某模块的文档 eval 运行一段代码，例如 `deno eval &quot;console.log(1 + 2)` fmt 内置的代码格式化程序（类似于 Go 语言中的 `gofmt`） help 打印某消息或某给定子命令的帮助信息 info 显示有关缓存的信息或与源文件有关的信息 install 将脚本安装为可执行文件 repl 开启 REPL 环境（默认子命令） run 运行给定文件名或 URL 的程序 test 运行测试 types 打印运行时的 TypeScript 声明 upgrade 升级 Deno 到最新版本ENVIRONMENT VARIABLES（环境变量）: DENO_DIR 设置 Deno 的基本目录（默认为 $HOME/.deno） DENO_INSTALL_ROOT 设置 Deno install 的输出目录（默认为 $HOME/.deno/bin） NO_COLOR 设置为禁用颜色 HTTP_PROXY 设置 HTTP 请求的代理地址（用来模块的下载和获取） HTTPS_PROXY 同上，但是用来处理 HTTPS 请求 如果你使用的是 Visual Studio Code 编辑器，建议你安装如下插件以简化使用 Deno 的繁琐操作： https://marketplace.visualstudio.com/items?itemName=axetroy.vscode-deno 译者注：接下来会有 VS Code 版的官方插件，到时候可以在 VS Code 插件市场中搜索。 简单的 “Hello World” 实战对于 Deno 中一个简单的 “Hello world” 程序，我们只需要创建一个相应的 .js 或 .ts 文件，并通过 deno run [文件名] 命令来执行。 如果是 .ts 文件，Deno 将编译后执行；而对于 .js 文件，Deno 将直接执行： 12// example.ts fileconsole.log('Hello from Deno 🖐') 然后在终端中输入如下命令执行： 123➜ deno run example.tsCompile file:///Users/aralroca/example.tsHello from Deno 🖐 因为 Deno 本身支持直接运行 TypeScript 文件，tsconfig.json 配置文件便是可选的。要手动导入 tsconfig.json 配置，则需要执行 deno run -c tsconfig.json [文件名]。 同时，Deno 会尽可能地支持 Web 标准，我们可以很方便的使用兼容浏览器环境的 window、fetch、Worker 变量。 本地监听 index.html 文件Deno 有它内置的标准库（https://deno.land/std/），因此我们可以直接从官方提供的 URL 上直接导入并使用这些模块。Deno 的目标之一包括支持运行一个存放于 URL 上、具有最小耦合性的单个可执行文件。这时便可以直接将这些模块导入到用户的项目中或者通过 deno run https:// ... 命令来在终端上执行。 我们可以使用 [https://deno.land/std/http/](https://deno.land/std/http/) 模块来创建 HTTP 服务器并本地监听一个 index.html 文件。 在接下来的示例中我们将创建 server.ts 和 index.html 两个文件。 index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Example using Deno&lt;/title&gt; &lt;/head&gt; &lt;body&gt; index.html served correctly &lt;/body&gt;&lt;/html&gt; server.ts 123456789101112131415import { listenAndServe } from 'https://deno.land/std/http/server.ts'listenAndServe({ port: 3000 }, async (req) =&gt; { if (req.method === 'GET' &amp;&amp; req.url === '/') { req.respond({ status: 200, headers: new Headers({ 'content-type': 'text/html', }), body: await Deno.open('./index.html'), }) }})console.log('Server running on localhost:3000') Deno 中，我们可以直接使用 ES 标准来导入模块，而不再需要遵循 Common.js 的标准。这意味着文件扩展名要始终位于末尾。而且 Deno 支持最新的如 async-await 等功能。 译者注：在 Node.js 早期的设计中，由于 ES 标准还没发展到如今的状态，Node.js 需要使用 Common.js 的模块规范来导入、导出模块。这虽然极大地推进了 JavaScript 模块化的发展，但也成了 ES 模块标准推出后急需解决但在 Node.js 中并不那么容易解决的历史遗留问题之一。 另外，我们不必再担心代码格式化问题。我们还可以直接使用内置的 deno fmt 命令来格式化文件，而无需 Node.js 中需要引入的 Prettier 等第三方工具。 首次执行 deno run server.ts 命令时，我们将会看到与上文“Hello World”示例的两个区别： 命令执行后、项目运行前，Deno 下载安装了“HTTP 模块”及其所有的依赖项，而不再需要使用 yarn 或 npm install 提前手动安装。由于缓存机制，这样的过程只发生在第一次。我们也可以使用 --reload 参数来清理缓存重新下载。 执行命令后终端抛出错误： Uncaught PermissionDenied: network access to &quot;127.0.0.1:3000&quot;, run again with the --allow-net flag。这是因为在 Deno 默认的安全性协议下，不允许未授权的程序访问网络或读取文件（示例中的 index.html）——这是一个对比 Node.js 来说重大的改进之一，Node.js 中任何库都可以通过 CLI 做很多用户未授权的事情。Deno 提供了控制安全性的可能，如使用 deno --allow-read=/etc 来限制程序只在 /etc 文件夹下拥有读取的权限。更多许可标志可以使用 deno run -h 来查看。 现在我们已经充分了解完毕，可以本地监听 index.html 了： 123➜ deno run --allow-net --allow-read server.tsCompile file:///Users/aralroca/server.tsServer running on localhost:3000 引入 WebSocketsWebSocket、UUID 以及其它对于 Node.js 来说必要的库都没有包含在 Node.js 的内核中。这意味着我们需要寻找第三方库来使用这些功能。现在，你可以直接在 Deno 的官方标准仓库中使用 WebSockets、UUID 等库了。因此，你不再需要担心这些库如果是第三方库的情况下，它们的不稳定性问题了——Deno 会直接维护这些功能。 为了继续完善我们这个简单的聊天室应用程序，我们来创建一个名为 chat.ts 的文件： 123456789101112131415161718192021222324252627282930313233343536import { WebSocket, isWebSocketCloseEvent,} from 'https://deno.land/std/ws/mod.ts'import { v4 } from 'https://deno.land/std/uuid/mod.ts'const users = new Map&lt;string, WebSocket&gt;()function broadcast(message: string, senderId?: string): void { if (!message) return for (const user of users.values()) { user.send(senderId ? `[${senderId}]: ${message}` : message) }}export async function chat(ws: WebSocket): Promise&lt;void&gt; { const userId = v4.generate() // Register user connection users.set(userId, ws) broadcast(`&gt; User with the id ${userId} is connected`) // Wait for new messages for await (const event of ws) { const message = typeof event === 'string' ? event : '' broadcast(message, userId) // Unregister user conection if (!message &amp;&amp; isWebSocketCloseEvent(event)) { users.delete(userId) broadcast(`&gt; User with the id ${userId} is disconnected`) break } }} 现在，改动 server.ts 来注册一个 /ws 路由以开放公开聊天功能： 1234567891011121314151617181920212223242526272829import { listenAndServe } from 'https://deno.land/std/http/server.ts'import { acceptWebSocket, acceptable } from 'https://deno.land/std/ws/mod.ts'import { chat } from './chat.ts'listenAndServe({ port: 3000 }, async (req) =&gt; { if (req.method === 'GET' &amp;&amp; req.url === '/') { req.respond({ status: 200, headers: new Headers({ 'content-type': 'text/html', }), body: await Deno.open('./index.html'), }) } // WebSockets Chat if (req.method === 'GET' &amp;&amp; req.url === '/ws') { if (acceptable(req)) { acceptWebSocket({ conn: req.conn, bufReader: req.r, bufWriter: req.w, headers: req.headers, }).then(chat) } }})console.log('Server running on localhost:3000') 为了实现我们的客户端部分，我们将选择使用 Preact 模块而无需通过 Npm、Babel、和 Webpack 进行前端预构建，就像我们在上一篇文章上介绍过的使用方式一样。 译者注：这里指的上一篇是作者的《一个使用 React API 但无需 Webpack 或 Babel 工具的应用实战》文章。文章中使用到了 Preact 库——一个遵循 React API 设计风格、不直接使用需要 Babel 转移的 JSX 语法、仅仅有 3kb 大小且性能优于 React 的前端库。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Chat using Deno&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\" /&gt; &lt;script type=\"module\"&gt; import { html, render, useEffect, useState, } from 'https://unpkg.com/htm/preact/standalone.module.js' let ws function Chat() { // Messages const [messages, setMessages] = useState([]) const onReceiveMessage = ({ data }) =&gt; setMessages((m) =&gt; [...m, data]) const onSendMessage = (e) =&gt; { const msg = e.target[0].value e.preventDefault() ws.send(msg) e.target[0].value = '' } // Websocket connection + events useEffect(() =&gt; { if (ws) ws.close() ws = new WebSocket(`ws://${window.location.host}/ws`) ws.addEventListener('message', onReceiveMessage) return () =&gt; { ws.removeEventListener('message', onReceiveMessage) } }, []) return html` ${messages.map((message) =&gt; html` &lt;div&gt;${message}&lt;/div&gt; `)} &lt;form onSubmit=${onSendMessage}&gt; &lt;input type=\"text\" /&gt; &lt;button&gt;Send&lt;/button&gt; &lt;/form&gt; ` } render(html`&lt;${Chat} /&gt;`, document.getElementById('app')) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果如下： 这是一个并不优雅的的聊天室：没有样式，但是功能丰富。毕竟我们的目的是了解 Deno 的工作方式。 第三方库与 Dep.ts 约定通过直接导入 URL 上的模块，我们可以像使用 Deno 标准库一样使用第三方库。 STD，Deno 内置标准库：https://deno.land/std/ X，Deno 第三方库：https://deno.land/x/ 但是，https：//deno.land/x/ 的生态系统如今还很小。好消息是，我们可以使用 https://www.pika.dev 中的软件包，来借助 Parcel 或 Minibundle 之类的工具以将 Node.js 的库编译为模块，以在 Deno 项目中重复使用它们。 译者注：pika.dev 用来在 Npm 上找到现代 ESM 软件包（更快、更小）；Parcel 是极速零配置的 Web 应用打包工具。 我们将使用 camel-case 包来将每个聊天消息转换转换为小驼峰法（camelCase）的文本。 让我们将如下内容添加到我们的 chat.ts 文件中： 1234import { camelCase } from 'https://cdn.pika.dev/camel-case@^4.1.1'// ...before codeconst message = camelCase(typeof event === 'string' ? event : '')// ... before code 好了，现在来执行 server.ts 会下载 camel-case 软件包，并会发现小驼峰法的转换功能已能成功使用： 但是，如果我想在多个文件中都使用 camelCase 这个软件包，将 URL 导入语句添加到每个文件中会很麻烦：URL 中包括着我们想要使用的软件包的具体版本，如果想要升级依赖项则需要搜索并替换所有相关文件中的导入语句。不用担心，Deno 的依赖项规则可以解决这类问题，我们可以创建一个 deps.ts 文件来导出当前项目的所有依赖项。 12// deps.ts fileexport { camelCase } from 'https://cdn.pika.dev/camel-case@^4.1.1' 此时再导入： 12345// chat.ts fileimport { camelCase } from './deps.ts'// ...const message = camelCase(typeof event === 'string' ? event : '')// ... 编写测试代码我们将构建一个 camelize.ts 函数来看看 Deno 如何进行测试。该函数返回小驼峰法转换后的文本，并带有一个附加值（与大写字母数量相同的若干个 🐪）。 12345678910/** * Return the text in camelCase + how many 🐪 * * @example \"this is an example\" -&gt; \"thisIsAnExample 🐪🐪🐪\" * @param text * @returns {string} */export function camelize(text: string) { // @todo} 顺便说一下，我们可以使用 deno doc [文件名] 命令可视化文件的文档： 123➜ deno doc camelize.tsfunction camelize(text: string) Return the text in camelCase + how many 🐪 让我们创建一个 test.ts 文件，Deno.test（） 内置在 Deno 的核心中，我们可以通过标准库中的 https://deno.land/std/testing/asserts.ts 来执行断言。 123456import { assertStrictEq } from 'https://deno.land/std/testing/asserts.ts'import { camelize } from './camelize.ts'Deno.test('camelize works', async () =&gt; { assertStrictEq(camelize('this is an example'), 'thisIsAnExample 🐪🐪🐪')}) 我们只需要执行 deno test 来运行当前项目的所有测试： 12345678910111213141516171819202122➜ deno testCompile file:///Users/aralroca/test.tsrunning 1 teststest camelize works ... FAILED (0ms)failures:camelize worksAssertionError: actual: undefined expected: thisIsAnExample 🐪🐪🐪 at assertStrictEq (asserts.ts:224:11) at test.ts:5:3 at asyncOpSanitizer ($deno$/testing.ts:36:11) at Object.resourceSanitizer [as fn] ($deno$/testing.ts:70:11) at TestApi.[Symbol.asyncIterator] ($deno$/testing.ts:264:22) at TestApi.next (&lt;anonymous&gt;) at Object.runTests ($deno$/testing.ts:346:20)failures: camelize workstest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out (0ms) 当然上面的执行结果会失败，因为我们尚未实现 camelize 函数具体的内容，但在这里我们可以看到错误是如何显示出来的。 在实现 camelize 函数之后： 123456789101112131415161718import { camelCase } from './deps.ts'/** * Return the text in camelCase + how many 🐪 * * @example \"this is an example\" -&gt; \"thisIsAnExample 🐪🐪🐪\" * @param text * @returns {string} */export function camelize(text: string) { const camelCaseText = camelCase(text) const matches = camelCaseText.match(/[A-Z]/g) || [] const camels = Array.from({ length: matches.length }) .map(() =&gt; '🐪') .join('') return `${camelCaseText} ${camels}`} 我们的测试结果将会通过： 123456➜ deno testCompile file:///Users/aralroca/camelize.tsrunning 1 teststest camelize works ... ok (3ms)test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out (3ms) 如果你想使用一个能监听文件改动的观察者程序，在测试代码改动后重新执行测试，而非每次都得在改动后再次执行测试命令，则可以使用基于 nodemon 的 https://deno.land/x/denon/ 库，然后运行 denon test 命令来提供热更新功能。 现在我们可以在 chat.ts 上使用这个 camelize 函数了。 浏览器调试想要在 Deno 中进行调试的话： 先在代码的某些行进行 debugger; 断点声明； 带上 --inspect-brk 参数：deno run --inspect-brk ... 或 deno test --inspect-brk ... 来调试/测试； 在 Chrome 中打开 chrome://inspect URL。 在“远程目标”标签下点击“检查”按钮。 按名为“继续”的脚本执行按钮，让代码将在你所设立的断点处暂停。 总结通过在 TypeScript 中创建一个简单的聊天室应用程序，我们了解了 Deno 的工作原理。我们在没有使用 Npm、package.json、node_modules、Webpack、Babel、Jest、Pettertier 的情况下完成了这些操作…因为我们不再需要它们，Deno 简化了它们。 我们从如上项目中探索了权限、Deno 命令、使用第三方依赖项、监听文件、WebSocket、格式化文件、测试和调试等 Deno 的重要功能。 我希望本文对入手在 2020 年 05 月 13 日发布的 Deno 1.0.0 会有所帮助。 本文的代码我上传了本文的相关代码在我的 Github 上： https://github.com/aralroca/chat-with-deno-and-preact 译者注：同时本文的代码也收录在了：https://github.com/hylerrix/deno-tutorial 的 demos 目录下。 参考文献 https://deno.land/ https://github.com/denoland/deno/tree/master/docs https://blog.logrocket.com/deno-1-0-what-you-need-to-know/ https://twitter.com/flaviocopes/status/1259068673966383105 https://www.youtube.com/watch?v=M3BM9TB-8yA https://github.com/denoland/deno https://en.wikipedia.org/wiki/Ryan_Dahl","link":"/blog/2020/05/25/00C-deno-websockets-preact/"},{"title":"从 Node 到 Deno：探索各大主流库替代方案","text":"原文地址：From Node to Deno 原文作者：Aral Roca 原文发布时间：2020-05-17 译者：@hylerrix, @YunKou 备注：本文已获原作者授权，同时本文会收录在《Deno 钻研之术》的翻译篇中。 备注：本文独立争取授权与翻译的同时，发现 InfoQ 等平台也独立授权翻译，可以作为对比。看来翻译的文章不能积压，要不也会错失风口~ 上周我发表了一篇关于 Deno 的文章：《Deno + WebSockets 打造聊天室应用》。在那之后，有很多困惑接踵而至——其中大部分都在思考如何在全新的 Deno 生态中来做 Node.js 上常做的工作。 所以我尝试整理一些 Node.js 中常见库在 Deno 下的相关解决方案。在这里我得强调，很多 Node.js 的模块都可以重用，并且没有必要为每个库都重新造一遍轮子。你可以访问 pika.dev 来寻找在 Deno 中可以直接使用的 ES 模块。 译者注：《Deno + WebSockets 打造聊天室应用》已经翻译并收录；pika.dev 用来在 Npm 上寻找符合现代 ESM 标准的软件包（更快、更小）。 本文的目录如下： Electron Forever / PM2 Express / Koa MongoDB PostgresSQL MySQL / MariaDB Redis Nodemon Jest、Jasmine、Ava… Webpack、Parcel、Rollup… Prettier NPM Scripts Nvm Npx 在 Docker 上运行 作为 Lambda 运行 小结 Electron我们可以使用基于 Node.js + Chromium 的 Electron 来依托 Web 技术栈创建桌面应用程序。那么我们可以在 Deno 下使用 Electron 吗？或者还有其它更多选择吗？ 答案是如今的 Electron 还远远不能运行在 Deno 上，我们必须寻找其它的解决方案。自从 Deno 选择用 Rust 语言构建其内核后，我们可以使用 Rust 生态上的 Web View @Bosop/web-view 来在 Deno 上运行桌面应用。 于是 @eliassjogreen/deno_webview 应运而生。 1234567891011121314151617181920212223242526272829303132333435import { WebView } from \"https://deno.land/x/webview/mod.ts\";const sharedOptions = { width: 400, height: 200, resizable: true, debug: true, frameless: false,};const webview1 = new WebView({ title: \"Multiple deno_webview example\", url: `data:text/html, &lt;html&gt; &lt;body&gt; &lt;h1&gt;1&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; `, ...sharedOptions,});const webview2 = new WebView({ title: \"Multiple deno_webview example\", url: `data:text/html, &lt;html&gt; &lt;body&gt; &lt;h1&gt;2&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; `, ...sharedOptions,});await Promise.all([webview1.run(), webview2.run()]); Forever / PM2Forever 和 PM2 是用来守护指定脚本其进程的两个 CLI 工具。PM2 相比 Forever 来说功能更为完善，相比还能同时作为负载均衡器。在 Node.js 中这两个工具都很有用，我们可以在 Deno 中也使用它们吗？ Forever 专为 Node.js 创造，就不用考虑了；而 PM2 可以运行 Node.js 之外的的脚本语言，因此我们可以让 PM2 和 Deno 搭配起来。 创建一个 app.sh 文件： 12#!/bin/bashdeno run -A myCode.ts 保存后在当前目录执行（请确保 pm2 已成功安装）： 1pm2 start ./app.sh Express / KoaExpress 和 Koa 以其强大的路由系统和友好的 HTTP 工具库（重定向、缓存等）而闻名于 Node.js 社区。我们可以在 Deno 中使用它们吗？答案是不能…但也有一些替代方案。 HTTP（标准库）Deno 内置的 STD 标准库已经涵盖了 Express 或 Koa 的绝大多数功能：https://deno.land/std/http/。 123456789import { ServerRequest } from \"https://deno.land/std/http/server.ts\";import { getCookies } from \"https://deno.land/std/http/cookie.ts\";let request = new ServerRequest();request.headers = new Headers();request.headers.set(\"Cookie\", \"full=of; tasty=chocolate\");const cookies = getCookies(request);console.log(\"cookies:\", cookies); 但由于 Deno 内置的 HTTP 标准库其声明路由的方式并不那么吸引人，我们来看看其它的解决方案，如下。 Oak (第三方库)受 Koa 启发，这是目前最优雅的解决方案之一：https://github.com/oakserver/oak。 123456789import { Application, } from \"https://deno.land/x/oak/mod.ts\";const app = new Application();app.use((ctx) =&gt; { ctx.response.body = \"Hello World!\";});await app.listen({ port: 8000 }); Abc (第三方库)类似于 Oak：https://deno.land/x/abc。 12345678import { Application } from \"https://deno.land/x/abc/mod.ts\";const app = new Application();app.static(\"/static\", \"assets\");app.get(\"/hello\", (c) =&gt; \"Hello!\") .start({ port: 8080 }); Deno-Express（第三方库）也许是最类似于 Express Framework 的替代品：https://github.com/NMathar/deno-express。 1234567891011121314import * as exp from \"https://raw.githubusercontent.com/NMathar/deno-express/master/mod.ts\";const port = 3000;const app = new exp.App();app.use(exp.static_(\"./public\"));app.use(exp.bodyParser.json());app.get(\"/api/todos\", async (req, res) =&gt; { await res.json([{ name: \"Buy some milk\" }]);});const server = await app.listen(port);console.log(`app listening on port ${server.port}`); MongoDBMongoDB 是一个广受欢迎的文档数据库，具有强大的可扩展性和灵活性。在 JavaScript 生态系统中已经被广泛使用：比如很多像 MEAN 或 MERN 这样的技术堆栈。 译者注：MEAN = MongoDB(数据库) + Express(后端) + Angular(前端) + Node.js(运行时)；MERN 同左，但其中的 R 代表 React。如上技术栈都对 JavaScript 语言极其友好。 因此，我们可以让 Deno 和 MongoDB 搭配起来，比如使用这个模块：https://github.com/manyuanrong/deno_mongo。 12345678910111213141516171819202122232425262728293031323334353637import { init, MongoClient } from \"https://deno.land/x/mongo@v0.6.0/mod.ts\";// Initialize the pluginawait init();const client = new MongoClient();client.connectWithUri(\"mongodb://localhost:27017\");const db = client.database(\"test\");const users = db.collection(\"users\");// insertconst insertId = await users.insertOne({ username: \"user1\", password: \"pass1\"});// findOneconst user1 = await users.findOne({ _id: insertId });// findconst users = await users.find({ username: { $ne: null } });// aggregationconst docs = await users.aggregation([ { $match: { username: \"many\" } }, { $group: { _id: \"$username\", total: { $sum: 1 } } }]);// updateOneconst { matchedCount, modifiedCount, upsertedId } = await users.updateOne( username: { $ne: null }, { $set: { username: \"USERNAME\" } });// deleteOneconst deleteCount = await users.deleteOne({ _id: insertId }); PostgresSQL 与 MongoDB 一样，PostgresSQL 也有一个 Deno 生态库：https://github.com/buildondata/deno-postgres。 123456789101112import { Client } from \"https://deno.land/x/postgres/mod.ts\";const client = new Client({ user: \"user\", database: \"test\", hostname: \"localhost\", port: 5432});await client.connect();const result = await client.query(\"SELECT * FROM people;\");console.log(result.rows);await client.end(); MySQL / MariaDB 与 MongoDB 和 PostgresSQL 一样，Deno 生态下也有 MySQL/MariaDB 的相关库：https://github.com/manyuanrong/deno_mysql。 123456789101112131415import { Client } from \"https://deno.land/x/mysql/mod.ts\";const client = await new Client().connect({ hostname: \"127.0.0.1\", username: \"root\", db: \"dbname\", poolSize: 3, // connection limit password: \"password\",});let result = await client.execute(`INSERT INTO users(name) values(?)`, [ \"aralroca\",]);console.log(result);// { affectedRows: 1, lastInsertId: 1 } Redis Redis 是著名的缓存数据库之一，Deno 下也有相关库：https://github.com/keroxp/deno-redis。 12345678import { connect } from \"https://denopkg.com/keroxp/deno-redis/mod.ts\";const redis = await connect({ hostname: \"127.0.0.1\", port: 6379});const ok = await redis.set(\"example\", \"this is an example\");const example = await redis.get(\"example\"); Nodemon Nodemon 在开发环境中监控文件的任何改变，并能自动更新服务器。这使 node 下的发更加有趣，无需手动停止并重启服务器来查看应用的变化。那么 Nodemon 可以在 Deno 中使用吗？ 抱歉，不能…但仍然有另一种选择：Denon：https://github.com/eliassjogreen/denon。 我们可以像是 deno run 执行脚本的方式一样使用 Denon。 1➜ denon server.ts Jest、Jasmine、Ava… 在 Node.js 的生态系统中，有很多不同的测试工具和方法。但直到现在，官方也没有推出一种正式的机制来测试 Node.js 代码。 在 Deno 中，可以使用官方测试 std 库测试：https://deno.land/std/testing。 12345import { assertStrictEq } from 'https://deno.land/std/testing/asserts.ts'Deno.test('My first test', async () =&gt; { assertStrictEq(true, false)}) 运行测试： 1➜ deno test Webpack、Parcel、Rollup… Deno 的优势之一是我们可以将 ESmodules 与TypeScript 一起使用，而无需诸如 Webpack、Parcel 或Rollup 之类的工具。 然而，可能你会想，如果给定一个文件目录，我们是否可以将其统一打包在有一个 JavaScript 文件里，并让其能直接在 Web 上以模块的形式运行。 答案是完全可行，我们可以通过 Deno 的 CLI 来实现。因此，不需要第三方的打包工具。 1➜ deno bundle myLib.ts myLib.bundle.js 现在可以将其加载到浏览器中了： 123&lt;script type=\"module\"&gt; import * as myLib from \"myLib.bundle.js\";&lt;/script&gt; Prettier 在过去的几年中，Prettier 在 JavaScript 生态中已广为人知，因为有了它，我们不必担心格式化文件。 事实上 Prettier 也可以在 Deno 上使用，但是没有必要：因为 Deno 有自己内置的格式化程序。 您可以使用以下命令格式化文件： 1➜ deno fmt NPM Scripts 我非常怀念的一件事就是曾在 package.json 中配置各种命令行脚本。但在 Deno 上，package.json 已经不复存在了。 Deno 上的一个简单的替代方法是使用 makefile 技术，用 make 命令运行。但如果你怀念 NPM 的语法，Deno 上也有一个 NPM 风格的脚本运行器：https://github.com/umbopepato/velociraptor 您可以使用脚本定义文件： 1234# scripts.yamlscripts: start: deno run --allow-net server.ts test: deno test --allow-net server_test.ts 并执行： 1➜ vr run &lt;SCRIPT&gt; 还有一个替代品是 denox，与 Velociraptor 非常相似。 Nvm Nvm 是一个用于管理多个 Node.js 版本的 CLI 工具，可以根据具体的项目来轻松升级或降级 Node.js 版本。 在 Deno 中，可以使用相当于 nvm 的 dvm ：https://github.com/axetroy/dvm。 1➜ dvm use 1.0.0 NpxNPX 在近几年非常流行，可以在 NPM 不安装的情况下直接执行 NPM 包。由于 Deno 是一个独立的生态系统，因此如今很多 NPM 库都不可直接使用，那么我们如何只使用 deno install [https://url-of-module.ts](https://url-of-module.ts) 而无需安装就能执行 Deno 模块呢？ 就像我们通过命令行运行项目一样，只不过这里把我们使用 URL 模块名的代替了文件名： 1➜ deno run https://deno.land/std/examples/welcome.ts 如上所见，我们不仅仅需要记住模块的名称，还要记住整个 URL 地址，这使它的使用更加麻烦；但是另一方面，也因此提供了更大的灵活性——我们可以运行任何文件，而不仅仅能运行像 Npx 这样在 package.json 中指定的二进制文件。 在 Docker 上运行 要在 Docker 内部运行 Deno，我们可以创建以下 Dockerfile： 123456789101112131415FROM hayd/alpine-deno:1.0.0EXPOSE 1993 # Port.WORKDIR /appUSER denoCOPY deps.ts .RUN deno cache deps.ts # Cache the depsADD . .RUN deno cache main.ts # main entrypoint.CMD [\"--allow-net\", \"main.ts\"] 构建并运行它： 1➜ docker build -t app . &amp;&amp; docker run -it --init -p 1993:1993 app 相关仓库：https://github.com/hayd/deno-docker 作为 Lambda 运行 要将 Deno 作为 lambda 运行，需要 Deno STD 库中有类似于这样的模块：https://deno.land/x/lambda。 12345678910111213141516import { APIGatewayProxyEvent, APIGatewayProxyResult, Context} from \"https://deno.land/x/lambda/mod.ts\";export async function handler( event: APIGatewayProxyEvent, context: Context): Promise&lt;APIGatewayProxyResult&gt; { return { body: `Welcome to deno ${Deno.version.deno} 🦕`, headers: { \"content-type\": \"text/html;charset=utf8\" }, statusCode: 200 };} 参考： Vercel 中的Deno：https://github.com/lucacasonato/now-deno。 AWS 中的Deno：https://blog.begin.com/deno-runtime-support-for-architect-805fcbaa82c3。 小结本文中，我难免会遗漏一些 Node 库如何在 Deno 使用的解决方案。如果有什么更多的地方需要我解释，欢迎告诉我。希望这篇文章能帮助你打破快速入手 Deno 应用开发的僵局。 这里可以探索 Deno 下绝大多数可以上手的库： https://deno.land/std https://deno.land/x https://www.pika.dev/","link":"/blog/2020/06/04/00E-from-node-to-deno/"},{"title":"开源爱好者月刊：第 5 期（202005）","text":"序言本月 07 号，一则 GitHub 重磅发布四大新功能的新闻迅速捕获了我的双眼。作为 Github 的铁杆粉丝，从入学到职场以来，我的个人职业发展都离不开 Github 的存在，也留下了 1100+ Star 仓库、1400+ 有效 Commit 和 235+ Follower 的成长故事。到底是什么让 Github 如此深深的影响了我们？Github 又是怎样慢慢地改变了人们的编程方式？没有 Github 的话开源的现状会怎样？带着这份好奇，值此六一儿童节之际，开启了本期开源爱好者月刊的微栏：更了不起的 Github。并作一个简要的梳理。 同时，社区中有关开源的新闻和新知识依旧层出不穷，一起来看看吧。 本刊从自身对开源的爱好出发，计划先以每月一刊的形式更新。同时，本刊站在众多巨人的肩上，离开这些或许现在会大不相同。本杂志开源（GitHub: ningowood/open-source-magazine），并即将配有一份独特的 UI 界面，更多动态，欢迎提交 issue，投稿或推荐你的开源内容。 微栏：更了不起的 Github 开源与商业的冲突问题，这么多年的发展过后已经形成了一个公理，单纯的开源真的不赚钱。保持独立运营的前提是，开源项目或企业有足够的资金支持，当马斯洛需求理论的面包还没满足时，又如何去追求开源的美好与意义？——InfoQ 每次 Github 发布重要更新，都激动人心。现如今已难以想到如果没有 Github（包括后来的 Gitlab），开源的现状会是怎样的贫瘠。或许市场上终究会有相应解决方案的出现，但 Github 的出现无疑加速了代码的协作与开源的进程，并做到了足够好的状态。 根据 Github Milestones、《深度复盘 GitHub 发展史：如何在 10 年内改变了人们的编程方式？》 和《刚刚，GitHub 重磅发布四大新功能》文章的梳理，并结合如今 Github 已经被微软收购两年的现状来看，这里节选一些 GitHub 历史上的重要时刻表，来重新回顾 Github 的征途之路。 阶段一【**2007-2011】：解决代码协作的市场痛点** 2007：Chris Wanstrath 为 GitHub 的雏形做第一次代码提交； 2008：Pull Request 功能发布；GitHub.com 正式启动；GitHub 发布 Gists 功能来托管代码片段； 2009：达到十万个用户；Issue 跟踪功能已发布； 2011：启动 GitHub Enterprise 企业版； 阶段二【2012-2018】：从快速增长到被微软收购 2012：在由 Andreessen Horowitz 领导的 A 轮融资中筹集了 1 亿美元； 2014：开始其安全漏洞赏金计划；GitHub Student Developer Pack 发布了； 2015：在旧金山举办首届年度 GitHub Universe 会议； 2016：发布了第一份多样性和包容性报告； 2017：GitHub 企业云启动；GitHub 开放其平衡员工知识产权协议（BEIPA）；GitHub Marketplace 与 14 个集成商一起启动；GitHub 在《福布斯》云计算 100 强中排名第 28 位；GitHub Desktop 1.0 发布；2017 年，用户在 GitHub 上总共添加了 28 亿行代码。 阶段三【2018-至今】：商业收购后的十足后劲 当微软用足以让科技界为之震惊的 75 亿美元收购 Github 后，Github 的商业底气更足，动作也更大。相继推出了如下对用户体验极其良好的服务： GitHub Actions：内置 CI/CD，对所有开源项目免费使用； GitHub Sponsors：用户可以用每月付费的方式赞助开源项目； GitHub Free：无限私有仓库免费供个人和团队使用； GitHub Mobile：移动版 GitHub App 正式上线； GitHub Archive Program：保存代码至少一千年； 收购与集成 NPM：支持世界上最大的开发人员生态系统； 总计托管了 1 亿个仓库、成百上千亿行代码，超过 5000 万用户。 更了不起的未来 GitHub 年度最大型的国际产品和社区活动 Github Satellite 2020 今年举办于线上，又双叒叕发布了四大全新功能，一方面拓展了 Github 的边界，另一方面也和微软生态进行了一定的整合，让商业支持更有力量，更了不起的未来持续进行中： Codespaces：一个云上的浏览器 IDE，可以在 GitHub 中秒开，这样开发者就可以很方便地为任意一个项目贡献代码，且编辑器技术栈依托于 VS Code，可以很方便地在浏览器中实现代码构建、测试、调试和部署； GitHub Discussions：交流和对话的专属场所，区别于用来反馈 Bug 或提出新特性的 Issues 区； Code scanning &amp; secret scanning：致力于查找零日漏洞及其变种，进一步提高代码安全性，设置后将对每个 Git Push 进行扫描来查找新的、潜在的安全漏洞，并且结果直接显示在该 PR 里； GitHub Private Instances：针对企业用户，提供增强的安全性、合规性和（安全）策略功能，包括 BYOK 加密、备份归档以及对区域数据主权要求的合规性等。 好文01、为什么现在整个开源运动都受到威胁 发布时间：2020-05-21 作者简介：Desire Athow 一直在沉思并撰写有关技术的文章。在 ITProPortal.com 工作了 8 年之后，他发现了全球性 Techfest 的乐趣，现在 Desire 负责 TechRadar Pro。他对任何硬件都具有亲和力，并坚决停止撰写晦涩的产品评论。 在大疫情期间，FOSS 项目争先恐后地筹集资金。迄今为止，已经影响了全球 170 多个技术活动。其中一些已被推迟，另一些已移至在线，但大多数已被完全取消。这对开源社区产生了重大影响，使备受瞩目的组织和项目面临越来越大的财务压力。负责评估开源许可证并防止“滥用开源运动固有的理想和精神”的组织开源倡议（OSI）表示，它需要筹集 60 万美元才能实现 2020 年的资金目标。 从表面上看，技术活动在帮助建立自由和开源软件（FOSS）社区方面的作用尚不明显。但是现实是，几十年来，举办和参加活动已帮助 FOSS 项目及其理事机构筹集资金，维持了它们的存在。此外，这些活动为 FOSS 项目提供了各种机会，以教育新用户和新加入的贡献者，协调他们的核心开发活动，执行项目整理工作并为未来的发展集思广益。 活动取消也可能对参与的开源项目和个人贡献者已经有限的资金产生负面影响。为了最大程度地减少已取消事件对 FOSS 生态系统的经济影响，来自社区的一群支持者及其企业支持者共同组成了 FOSS Responders 工作组。除了建立基础基金外，该小组还确定了最需要支持的开源活动和社区，并且还希望为无法吸收会议相关取消费用的个人提供支持。如果你想支持开源社区，这里有一系列由 FOSS 基金会设立的众筹活动，以帮助减轻遭受的资金挫折。 02、如何为开源软件撰写文章 发布时间：2020-05-26 作者简介：Dawn Parzych 是 LaunchDarkly 的一名开发倡导者，她使用讲故事的能力来撰写和谈论技术与心理学的交集。她乐于帮助人们在工作和生活中取得更大的成功。她使技术信息易于访问，并尽可能避免使用流行语和专业术语。Dawn 曾在 DevOpsDays、Velocity、Interop 和Monitorama 发表演讲。她的文章出现在许多技术出版物中。业余时间，她担任 Write / Speak / Code 的章节组织者，并在 Seattle DevOps Days 的组织委员会任职。 开源社区入门的一种方法是撰写关于开源的文章。你可以提供技术文档、共享软件使用方式或为 Opensource.com 撰写文章。但是，开始写作说起来容易做起来难。Dawn 听到的不写的两个最常见的借口是：“我没什么好说的”和“我不是一个好作家”。Dawn 在本文中尝试提供更多的帮助来消除这两个观念。 你应该写什么？寻找经常被遗忘的故事；对于某些人来说，写作的最大障碍是产生一个想法或话题。切记：你的作品是对你的反映。没有人会以你的方式讲述这个故事。你的经验和观点可能正是其他人所需要的。可以问问自己：“最近学到了什么”？“经常问什么问题”？“最近是否对搜索的文章不满意”？“参加过会议或研讨会”？“是否开始使用新工具”？如果回答“是”，则可以以此切入来写相关介绍、总结、观念文章。 你正在撰写哪种类型的文章？确定你的文章类型：入门指南、博客、白皮书/电子书、回顾性文章。内容的类型将影响你的写作风格和语气。博客更加非正式和对话性，技术文档更加正式和具有指导意义。 你是为谁写的？每篇著作都应该有一个单一的受众。受众是你正在写作的人的类型。在开始写作之前，它有助于记下读者的一些特征。重要的是要考虑你为谁写的东西，以及你不是为谁写的东西-确定目标受众将决定包括哪些内容和不包括哪些内容。 话语很重要。你选择的字词会对读者产生影响。难以理解的单词会使文章难以理解。陌生的单词会使读者感到愚蠢。某些单词可能会意外地冒犯读者。作为作家的目标是避免所有这些。就是这样。切记：使用日常语言、知道要避免的单词、使用包容性语言等。 修改和编辑。写作是一个反复的过程。如果你认为作家坐在办公桌前，并且在一小时内准备好一篇完整的文章准备发表，请再重新深思一下。对 Dawn 来说，有些文章需要数周才能完成。切记：写一份粗略的草稿、调整和编辑草稿、适度的使用标点符号、不要害怕在写作上寻求帮助。 风格指南。样式指南提供了改善书面交流的标准。它们包括标点符号，语法和单词用法等方面。如果为您的公司编写文档，请检查其是否使用样式指南。如：Google Developer 文档指南、Microsoft 写作风格指南、美联社风格书等。 03、开源 , 一种全新的创业模式，正在悄然袭来 发布时间：2020-05-04 作者简介：开源社是由国内外支持开源的企业、社区及个人，依“贡献、共识、共治”原则，所组织的开源联盟，旨在共创健康可持续发展的开源生态体系，并推动中国开源社区成为全球开源软件的积极参与及贡献者。 大多数优秀的程序员从事编程工作，不是因为期望获得报酬或公众称赞，而是因为编程真的很有趣。——Linus Torvalds 。 开源是一种新的开发模式，在源头上的确为不少创业公司解决了技术与产品原型的启动、成本、质量、更新迭代时间、早期用户拓展的一些问题。然而，开源绝不仅止助力创业，更是各种企业乃至于社会与国家及全球经济转型的重要契机。除了传统的企业主导的资本主义与国家主导的社会主义之外，分享经济 (主义) 或将崭露头角甚至鼎足而立，而开源运动在分享经济里已经是最主要的根基。 2020 年，全球形势风云变化，资本市场跌宕起伏，经济危机迫在眉睫，创业公司面临的不再是如何发展，而是生死存亡问题。融资（资本紧缩）、用户（用户红利消失）、商业化（客户资源稀缺），在创业者面前的这三座大山，犹如千钧压顶，令人望而生畏。这既是最坏的年代，也是最好的年代，开源，一种新兴的革命力量正悄然来袭，即将在科技创业的草原上点燃星火，照亮前路，并最终形成燎原之势，深刻改变人类的未来。 过去十年，创业有曹操型、孙权型、刘备型三种模式，开源是第四种，刘邦型； 为什么是开源：低投入，低门槛，低风险，高回报； 开源在创业层面，有着不可比拟的巨大优势； 全球开源产业已初步形成，无限机会孕育其中。 04、信任是开源的基石 发布时间：2020-05-09 作者简介：Vipin Bharathan，加密与区块链相关撰稿人，写了很多关于金融市场基础设施通过区块链破坏企业和国家边界的文章。 我们每天都会遇到的问题是对数字生活信任的不连贯性。我们如何在数字领域证明我们是谁？我们如何相信你所连接的网站确实是它声称的名称？当你走进商店或政府大楼时，我们会掏出钱包，拿出我们的驾驶执照或信用卡，让他们信任我们的身份，以便我们与他们开展任何业务。与物理世界相反，互联网，IP 或互联网协议的基本协议没有内置身份。很好，因为我们大多数人与 Internet 进行交互的方式都是通过协议层的技术和治理堆栈进行的。但是，坚如磐石的信任框架不存在的。 在数字领域，这通常涉及第三方平台，许多网站允许我们使用基于帐户的系统登录；我们在 Google、Facebook、Linkedin 或 Twitter 中的帐户。第三方平台知道我们所有的互动，然后可以通过间接或直接出售知识来货币化，但难免在我们的生活中引入摩擦。 我们如何在互联网规模上创建用于数字交互的基础架构？IP 信任基金会（TOIP）希望不依赖第三方平台，使用户或持有人的地位比今天更好。信任的基本交互包括三方的交互：凭证的持有者、发行者、验证者。最初，它被视为技术解决方案中的工程问题。很快变得很清楚，它需要一个治理层。上面概述的三方关系中有一个看不见的第四方。创建和交换凭证的基础治理层。从本质上讲，这与 Internet 网络堆栈的分层网络拓扑相似。最低级别是公共事业，通常是公共可读的区块链。随着我们的发展，行动将移至诸如移动或便携式设备之类的边缘设备中，直到最终在数字生态系统（如医疗供应链）中达到顶点。 05、独立开源开发者能否在疫情中幸免？ 发布时间：2020-05-19 作者简介：Matt Asay 是一位资深的技术专栏作家，曾为 CNET、ReadWrite 和其他技术媒体撰写过文章。Asay 还曾担任领先的移动和大数据软件公司的各种执行职务。Matt 是 Amazon Web Services 的一名员工。他会表达自己的观点，而不是雇主的观点。 许多重要的项目由开发人员志愿维护，他们现在可能会有更多紧迫的生存需求。开源已经蓬勃发展了几十年，纵使在财务困难时期开源表现的依然特别出色、开源社区有能力在经济衰退期间维持自身甚至成长（像现在），但现在独立维护者所承受的时间和财务压力比一个月或两个月前还要大。 换句话说，开源仍然很有趣，但其中的一些“乐趣”可能会在当下社会的经济压力中被吞没，那么该怎么办？希望开源社区能够比以往更强大地经受住这一流行病的不是“开源”，而是紧接下来的一个词“社区”。Curl 贡献者说，正是由于有了这个社区，他不仅获得了想法和见解，而且还获得了能量和支持，以度过这一看似永无止境的大疫情。 简而言之，我们应该关心许多独立的开源维护者，让这种混乱的大希望是：他们并不是一个人，至少不是全部。开源的力量在于社区，现在比以往任何时候都更为重要。 06、更多文章推荐 [05-04] 使用开源为孩子们创建交互式学习游戏 [05-06] 开源项目中最重要的部分 [05-07] 开发者们请注意软件供应链攻击 [05-08] 设置成功的开源计划办公室（OSPO）指南 [05-12] Red Hat：基于开源订阅的模型将变得更具吸引力 [05-13] 开源社区和标准机构之间的边界正在消失 [05-14] Linux 不是 Windows：为什么慕尼黑又从 Microsoft 转移回开源了？ [05-15] 为什么图表对开源项目文档至关重要 [05-15] 如何避免开源陷阱 [05-16] 为什么欧洲大学选择开源软件进行教学 [05-21] 专有软件真的比开放源代码更好吗？ [05-22] 看看 Jitsi 如何成为 Zoom 的“安全”开源替代品 [05-24] 是否可以仅使用免费软件来召开会议？ [05-26] 开源对企业的最大影响可能不是软件本身 [05-26] 问答：开源如何使 Kubernetes 吸引企业应用程序开发人员 [05-28] 桌面 Linux：开放源码为何要取得新突破 [05-29] 开源数据如何推动汽车创新 [05-30] 开放标准如何在变化的世界中指导我们 [05-31] 什么是开源项目治理？ 快讯 Octoverse 聚焦：分析 COVID-19 初期的开发人员生产力，工作节奏和协作。面对不确定性，开发人员仍然在继续做贡献，表现出了很好的韧性；开发人员的工作时间每天最多增加一小时，工作日和周末都是如此；开发活动的模式可能表明了开发者的职场倦怠；人们的合作越来越多，尤其是在开源项目上。[2020-05-06] 中国的开源之夏来了！中国科学院软件研究所与 openEuler 社区正在共同举办面向高校学生的暑期活动—“开源软件供应链点亮计划—暑期2020”，此次活动受到 Google Summer of Code（GSoC）启发，目标是进一步推动国内开源社区的发展。[2020-05-09] Eclipse Foundation 宣布通过建立自己的欧洲组织巩固其对全球扩张的承诺。”开放源代码正在推动国际创新与合作，并已成为欧洲行业的战略。在继续欢迎和支持来自世界各地的新成员的同时，将更多的资源集中在这个关键的地理位置上是一个容易的决定。从我们在欧洲的新基地开始，我们期待继续促进全球可持续的开源生态系统的增长，为开发人员和我们服务的许多行业带来广泛的利益”。[2020-05-12] 时任微软总裁 Brad Smith 对公司过去的开源立场表示遗憾。Smith 在公司仍反对开源的时候曾担任微软的律师之一，处于“历史错误的一面”。Brad Smith相信，当技术改变世界时，创造技术的公司有责任帮助解决他们在创造中所扮演的角色。科技公司和政府必须共同努力应对挑战，并适应技术带来的变化。[2020-05-14] IBM 启动开源可访问性工具包。IBM 的可访问性计划总监 Simeon McAleer 在博客中宣布，该公司将推出 Equal Access Toolkit 开源产品和设计工具包，旨在帮助设计人员和开发人员将可访问性嵌入其工作流程中，而无需外部咨询。该工具包具有一组使可访问性更容易量化的组件。有用于创建可访问企业产品的团队的“平等访问”准则，以及可访问性检查程序，可审核基于Web的组件和解决方案以解决可访问性问题。[2020-05-19] SegmentFault 思否开源项目支持计划启动，为你的开源项目助力！为助力优质开源项目成长， SegmentFault 思否社区作为服务于开发者的技术社区，正式推出「SFOSSP - 思否开源项目支持计划」，我们希望借助社区的资源对开源项目进行相关的宣传推广，并作为一个长期项目助力开源事业的发展，与广大开发者共建开源新生态。[2020-05-19] 软件安全状况（SOSS）：每 10 个应用中有 7 个使用未修补安全性的开源库。这项研究分析了整个 Veracode 平台的开源库，其中包括 351,000 个唯一的外部库。Eng强调说，库之间的依赖关系使开源软件容易遭受代码以外的一系列攻击，漏洞也因框架而异：JavaScript、Ruby、PHP 和 Java 的大多数攻击都来自于传递包含，而 .NET、Swift 和 Go 具有更直接的依赖性。[2020-05-20] GNOME 获得了巨大的开源专利胜利。在2019年，Rothschild Patent Imaging（RPI）起诉 GNOME 基金会，理由是其违反了“无线图像分发系统和方法专利”（美国专利号9,936,086）。在过去六年中已提起714项诉讼。现在，出人意料的是，流行的同名 Linux 桌面的制造商 GNOME 不仅赢得了不得对 Rothschild 专利提起诉讼的版本和约定，而且还赢得了根据现有 Open 发行的任何软件的版本和约定。 Source Initiative（OSI）批准的许可证。[2020-05-22] 扎克伯格在 23 个生物医学开源项目上投入 380 万美元。“每天有成千上万的科学家使用开源软件进行研究。科学家应该拥有更好的工具，我们通过支持将促进生物医学科学并促进对关键软件的更多访问的开源项目来满足这一需求” 。[2020-05-27] Strapi 推出其开源 Headless 内容管理系统（CMS）新版本。与 WordPress，Joomla 和 Drupal 这样的流行CMS不同，Headless CMS 独立于网站的前端，其所有重点都放在后端用于存储和交付结构化内容的存储库上。通常使用 JSON 或 XML，通过 RESTful API 将这些内容显示出来。[2020-05-28] CR Deck Mk.1 是一款基于 North Star 的开源 AR 耳机，具有 Ultraleap 手动跟踪功能。“一个开源的，社区驱动的 AR 硬件平台，具有 Unity 和 SteamVR 集成，它围绕世界上最先进的光学手跟踪技术构建。在高达 120Hz 的频率下，每只眼睛具有出色的 1440x1600px 显示屏”。[2020-05-29] 许可证：MIT1234567Copyright (C) &lt;year&gt; &lt;copyright holders&gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. MIT 许可协议是许多软件许可条款中被广泛使用的一种，由麻省理工学院于 1988 年发布。与其他常见的软件许可协议（如GPL、LGPL、BSD）相比，MIT 是相对宽松的软件许可协议。MIT 内容与三条款 BSD许可协议（3-clause BSD license）内容颇为近似，但是赋予软件被许可人更大的权利与更少的限制。 被许可人权利：被许可人有权利使用、复制、修改、合并、出版发行、散布、再许可和/或贩售软件及软件的副本，及授予被供应人同等权利，惟服从以下义务。 被许可人义务：在软件和软件的所有副本中都必须包含以上著作权声明和本许可声明。 其它重要特性：此许可协议并非属 copyleft 的自由软件许可协议条款，允许在自由及开放源代码软件或非自由软件（proprietary software）所使用。MIT 的内容可依照程序著作权者的需求更改内容。此亦为 MIT 与BSD（The BSD license, 3-clause BSD license）本质上不同处。MIT 许可协议可与其他许可协议并存。另外，MIT 条款也是自由软件基金会（FSF）所认可的自由软件许可协议条款，与 GPL 兼容。 项目01、Ventoy：一种新的可启动 U 盘解决方案 Ventoy 是一个制作可启动 U 盘的开源工具。有了 Ventoy 你就无需反复地格式化 U 盘，你只需要把 ISO 文件拷贝到 U 盘里面就可以启动了，无需其他操作。你可以一次性拷贝很多个不同类型的 ISO 文件，在启动时 Ventoy 会显示一个菜单来选择。无差异支持 Legacy BIOS 和 UEFI 模式。目前已经测试了各类超过 260+ 个 ISO 文件，同时提出了“Ventoy Compatible”的概念，若被支持则理论上可以启动任何 ISO 文件。 02、Jukebox：自动点唱机：音乐模型生成器 来源于论文，该自动点唱机基于一种神经网络，可以产生包括各类基本音乐，作为各种类型和艺术家风格的原始音频。未来将发布模型权重和代码，以及用于探索生成的样本的工具。该自动点唱机会产生各种音乐和唱歌风格，并泛化成训练期间看不到的歌词。官网上提供的所有歌曲均由语言模型和 OpenAI 研究人员共同编写。 03、Deno：一个安全的 JavaScript 和 TypeScript 运行时 Deno 是全新的 JavaScript / TypeScript 运行时，基于 V8，Rust 和 Tokio 构建。Deno 旨在为现代程序员提供高效且安全的脚本环境；Deno 将始终作为单个可执行文件分发；Deno 明确承担了运行时和程序包管理器的角色；Deno 使用与浏览器兼容的标准协议来加载模块：URL。此外，Deno 可能是使用 Bash 或 Python 编写的古老实用程序脚本的一个不错的替代。 品牌*01、[基金会] *GNOME 基金会 GNOME 基金会是一个非营利性组织，致力于促进 GNOME 项目完成其目标，并为公众创建一个免费的软件计算平台——该平台旨在优雅，高效且易于使用。 GNOME 基金会在其贡献者开发代码、消除错误、编写文档并为用户提供帮助的过程中起着指导作用，并提供了资源和基础架构。GNOME 指导发行并确定哪些软件归为官方项目，尽管其将大部分权限委托给专业团队。 GNOME 基金会的成员资格对所有 GNOME 贡献者开放，董事会的每个成员都是 GNOME 社区的贡献成员。成为基金会成员可以增强自己在项目中的发言权，并使自己有机会将就引导 GNOME 项目走向未来的目标进行投票。 *02、[公司] *IBM 开源 在开放源代码领域，IBM 是无与伦比的：从量子和区块链到容器、人工智能和操作系统，IBM 始终在积极领导当今最有影响力的项目，并创建新项目以推动技术向明天发展。IBM 非常重视开源，会对员工进行有关参与开放源代码社区的最佳实践以及开放式治理重要性的培训，并授权他们创建解决其业务和个人问题的开放源代码项目。 尽管开源社区一直很欣赏 IBM 在开源运动中的作为，但是直到 IBM 近年来收购 Red Hat 为止，在这些社区之外的并不会将 IBM 与开源相关联。但事实是，IBM 从一开始就参与开源。在与开放源代码相关联的许多公司甚至还未成立之前，IBM 就在支持新兴社区，为开放源代码许可证的开发做出贡献，并倡导开放式治理和开放标准。 IBM 是最早的开源拥护者之一，支持 Linux，Apache 和 Eclipse 等有影响力的社区，并推动开放许可证、开放式管理和开放标准的发展。在 1990 年代后期，IBM 以专利承诺、10 亿美元的技术和其他资源投资支持 Linux，并在 2000 年帮助建立 Linux 基金会；在1999年，IBM 帮助创建了 Apache 软件基金会（ASF），贡献了数千行代码和专用资源来支持 Apache Web Server 项目；在 2004 年，IBM 领导了 Eclipse Foundation 的创建。 *03、[基金会] *Open Stack 基金会 OpenStack 基金会与来自全球 187 个国家的 105,000 多名社区成员一起促进开放基础设施的全球开发、分发和采用发展。OpenStack 基金会成立于 2012 年 9 月，旨在为 OpenStack 云操作系统提供一个独立的家园，此后，该操作系统已成为历史上规模最大，用途最广泛的开源项目之一。 OpenStack Foundation 的目标是通过提供一组共享资源来建立社区，促进协作并支持开源技术集成，从而为开发人员，用户和整个开放基础架构生态系统提供服务。主要活动包括组织大规模的测试基础架构，社区管理，以及每年在包括开放基础架构峰会（以前称为 OpenStack 峰会）在内的全球活动中召集超过 20,000 名开放基础架构爱好者。 2017年12月，OpenStack 基金会开始孵化新的战略重点领域，从容器基础架构，CI / CD 和边缘计算开始。战略重点领域包括新的试点项目和社区，其中第一个是 Kata Containers，Zuul 和 Edge Computing Group。对开放基础设施感兴趣的任何人都可以免费获得 OpenStack Foundation 的个人成员资格。希望个人成员通过技术贡献或社区建设工作参与社区活动，并在年度选举中投票选举董事会成员。 荐书：用开源打造你的未来 自由和开源是如今软件开发的基础，离不开每一位开发者的贡献。通过本书，你可以探索开源运动的由来、推动开源运动发展的基本原则、开源为什么愈发重要、选择适合你职业目标的合适项目来发展自己以及与志同道合的人共建社区、改变世界。这里有程序员、作家、设计师和所有对软件感兴趣的人，都在通过开源运动贡献自己的力量。 本书不假定你是程序员，甚至不假定你具有使用免费开放源代码软件的经验。本书会助力你在作出贡献之前先掌握所需要的各类知识和工具，并在贡献后逐步扩大贡献影响力。无论是代码、设计还是文章、运营社区……任何人都可以贡献力量！在今天留下自己的印记，在帮助别人的同时也帮助自己。 订阅本刊每月底择机发布，以 Github 为中心、微信公众号（@ningowood）、语雀和知乎为同步平台，任何想法和新内容的推荐欢迎以 Github Issue 的形式进行交流与知识共享。","link":"/blog/2020/06/01/00D-osm-005/"}],"tags":[{"name":"凝果开源","slug":"凝果开源","link":"/blog/tags/%E5%87%9D%E6%9E%9C%E5%BC%80%E6%BA%90/"},{"name":"扑克牌","slug":"扑克牌","link":"/blog/tags/%E6%89%91%E5%85%8B%E7%89%8C/"},{"name":"故事","slug":"故事","link":"/blog/tags/%E6%95%85%E4%BA%8B/"},{"name":"前端","slug":"前端","link":"/blog/tags/%E5%89%8D%E7%AB%AF/"},{"name":"程序员","slug":"程序员","link":"/blog/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"总结","slug":"总结","link":"/blog/tags/%E6%80%BB%E7%BB%93/"},{"name":"JavaScript","slug":"JavaScript","link":"/blog/tags/JavaScript/"},{"name":"React","slug":"React","link":"/blog/tags/React/"},{"name":"开源爱好者月刊","slug":"开源爱好者月刊","link":"/blog/tags/%E5%BC%80%E6%BA%90%E7%88%B1%E5%A5%BD%E8%80%85%E6%9C%88%E5%88%8A/"},{"name":"疫情","slug":"疫情","link":"/blog/tags/%E7%96%AB%E6%83%85/"},{"name":"Rome","slug":"Rome","link":"/blog/tags/Rome/"},{"name":"工具链","slug":"工具链","link":"/blog/tags/%E5%B7%A5%E5%85%B7%E9%93%BE/"},{"name":"开源女性","slug":"开源女性","link":"/blog/tags/%E5%BC%80%E6%BA%90%E5%A5%B3%E6%80%A7/"},{"name":"Deno","slug":"Deno","link":"/blog/tags/Deno/"},{"name":"安装","slug":"安装","link":"/blog/tags/%E5%AE%89%E8%A3%85/"},{"name":"TypeScript","slug":"TypeScript","link":"/blog/tags/TypeScript/"},{"name":"Awesome","slug":"Awesome","link":"/blog/tags/Awesome/"},{"name":"WebSockets","slug":"WebSockets","link":"/blog/tags/WebSockets/"},{"name":"Node","slug":"Node","link":"/blog/tags/Node/"},{"name":"Github","slug":"Github","link":"/blog/tags/Github/"}],"categories":[{"name":"凝果开源","slug":"凝果开源","link":"/blog/categories/%E5%87%9D%E6%9E%9C%E5%BC%80%E6%BA%90/"},{"name":"个人成长","slug":"个人成长","link":"/blog/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/"},{"name":"JavaScript 技术精进","slug":"JavaScript-技术精进","link":"/blog/categories/JavaScript-%E6%8A%80%E6%9C%AF%E7%B2%BE%E8%BF%9B/"},{"name":"开源爱好者月刊","slug":"开源爱好者月刊","link":"/blog/categories/%E5%BC%80%E6%BA%90%E7%88%B1%E5%A5%BD%E8%80%85%E6%9C%88%E5%88%8A/"},{"name":"Deno 钻研之术","slug":"Deno-钻研之术","link":"/blog/categories/Deno-%E9%92%BB%E7%A0%94%E4%B9%8B%E6%9C%AF/"}]}